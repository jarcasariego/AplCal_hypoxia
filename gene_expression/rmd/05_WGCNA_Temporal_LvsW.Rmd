---
title: "WGCNA_temporal_WvsL"
author: "Javier Rodriguez Casariego"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
# Set the working directory to the R project's root folder
setwd("/Volumes/JARC_2T/NSF-CREST_Postdoc/LongTerm_Hypoxia_exp/AplCal_hypoxia")

# Ensure the working directory is not reset for each chunk
knitr::opts_knit$set(root.dir = "/Volumes/JARC_2T/NSF-CREST_Postdoc/LongTerm_Hypoxia_exp/AplCal_hypoxia")
knitr::opts_knit$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
```

```{r data input and cleaning}
# Load the package
library(WGCNA)
library(DESeq2)
library(tidyverse)

# The following setting is important, do not omit.
options(stringsAsFactors = FALSE);

# load and prepare datasets 
load('gene_expression/output/TS_output/LCvsWC_Abdominal/timeSeries_obj_LCvsWC_abdominal.Rdata')
load('gene_expression/output/TS_output/LCvsWC_Pleural/timeSeries_obj_LCvsWC_pleural.Rdata')

countMatrix_A<-assays(A_TS_object@exp_data)$norm
counts.means <-apply(countMatrix_A,1,mean)
#keep only genes with count means >=10 and eliminate bads
AData <-countMatrix_A[which(counts.means>=10),]

countMatrix_P<-assays(P_TS_object@exp_data)$norm
counts.means <-apply(countMatrix_P,1,mean)
#keep only genes with count means >=10 and eliminate bads
PData <-countMatrix_P[which(counts.means>=10),]

# Take a quick look at what is in the data sets (caution, longish output):
dim(AData)
colnames(AData)
dim(PData)
colnames(PData)

#Separate datasets by cross
datTraits_A <- read.csv('gene_expression/data/LCvsWC_A/sample_meta.csv')
datTraits_P <- read.csv('gene_expression/data/LCvsWC_P/sample_meta.csv')
WC_AData <- AData[,colnames(AData) %in% datTraits_A[datTraits_A$group == "Wild_cross",]$sample]
LC_AData <- AData[,colnames(AData) %in% datTraits_A[datTraits_A$group == "Lab_cross",]$sample]
WC_PData <- PData[,colnames(PData) %in% datTraits_P[datTraits_P$group == "Wild_cross",]$sample]
LC_PData <- PData[,colnames(PData) %in% datTraits_P[datTraits_P$group == "Lab_cross",]$sample]

# Work with two sets:
nSets = 2;
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels = c("Wild_cross","Lab_cross")
shortLabels = c("WC", "LC")
# Form multi-set expression data: columns starting from 9 contain actual expression data.
multiExpr_A = vector(mode = "list", length = nSets)
multiExpr_A[[1]] = list(data = as.data.frame(t(WC_AData))); 
names(multiExpr_A[[1]]$data) = rownames(WC_AData);
rownames(multiExpr_A[[1]]$data) = colnames(WC_AData);
multiExpr_A[[2]] = list(data = as.data.frame(t(LC_AData))); 
names(multiExpr_A[[2]]$data) = rownames(LC_AData);
rownames(multiExpr_A[[2]]$data) = colnames(LC_AData)

multiExpr_P = vector(mode = "list", length = nSets)
multiExpr_P[[1]] = list(data = as.data.frame(t(WC_PData))); 
names(multiExpr_P[[1]]$data) = rownames(WC_PData);
rownames(multiExpr_P[[1]]$data) = colnames(WC_PData);
multiExpr_P[[2]] = list(data = as.data.frame(t(LC_PData))); 
names(multiExpr_P[[2]]$data) = rownames(LC_PData);
rownames(multiExpr_P[[2]]$data) = colnames(LC_PData);

# Check that the data has the correct format for many functions operating on multiple sets:
exprSize = checkSets(multiExpr_A)
exprSize  ##so far so good!! 

# Check that all genes and samples have sufficiently low numbers of missing values.
gsg = goodSamplesGenesMS(multiExpr_A, verbose = 3);
gsg$allOK

# if false run cleanup below
if (!gsg$allOK)
{
# Print information about the removed genes:
if (sum(!gsg$goodGenes) > 0)
printFlush(paste("Removing genes:", paste(names(multiExpr_A[[1]]$data)[!gsg$goodGenes],
collapse = ", ")))
for (set in 1:exprSize$nSets)
{

if (sum(!gsg$goodSamples[[set]]))
printFlush(paste("In set", setLabels[set], "removing samples",
paste(rownames(multiExpr_A[[set]]$data)[!gsg$goodSamples[[set]]], collapse = ", ")))
# Remove the offending genes and samples
multiExpr_A[[set]]$data = multiExpr_A[[set]]$data[gsg$goodSamples[[set]], gsg$goodGenes];
}
# Update exprSize
exprSize = checkSets(multiExpr_A)
}
exprSize

# Check that all genes and samples are ok after cleaning.
gsg = goodSamplesGenesMS(multiExpr_A, verbose = 3);
gsg$allOK # TRUE!! all clear!!

# For pleural Now
exprSize = checkSets(multiExpr_P)
exprSize  ##so far so good!! 
gsg = goodSamplesGenesMS(multiExpr_P, verbose = 3);
gsg$allOK
if (!gsg$allOK)
{
# Print information about the removed genes:
if (sum(!gsg$goodGenes) > 0)
printFlush(paste("Removing genes:", paste(names(multiExpr_P[[1]]$data)[!gsg$goodGenes],
collapse = ", ")))
for (set in 1:exprSize$nSets)
{

if (sum(!gsg$goodSamples[[set]]))
printFlush(paste("In set", setLabels[set], "removing samples",
paste(rownames(multiExpr_P[[set]]$data)[!gsg$goodSamples[[set]]], collapse = ", ")))
# Remove the offending genes and samples
multiExpr_P[[set]]$data = multiExpr_P[[set]]$data[gsg$goodSamples[[set]], gsg$goodGenes];
}
# Update exprSize
exprSize = checkSets(multiExpr_P)
}
exprSize

# Check that all genes and samples are ok after cleaning.
gsg = goodSamplesGenesMS(multiExpr_P, verbose = 3);
gsg$allOK # TRUE!! all clear!!
```

```{r detecting outliers}

sampleTrees = list()
for (set in 1:nSets)
{
sampleTrees[[set]] = hclust(dist(multiExpr_A[[set]]$data), method = "average")
}

pdf(file = "gene_expression/output/WGCNA/Abdominal_Consensus_SampleClustering.pdf", width = 12, height = 12);
par(mfrow=c(2,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
xlab="", sub="", cex = 0.7);
dev.off();

sampleTrees = list()
for (set in 1:nSets)
{
sampleTrees[[set]] = hclust(dist(multiExpr_P[[set]]$data), method = "average")
}

pdf(file = "gene_expression/output/WGCNA/Pleural_Consensus_SampleClustering.pdf", width = 12, height = 12);
par(mfrow=c(2,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
xlab="", sub="", cex = 0.7);
dev.off();
# AC180
## all good!!

```
```{r prepare trait data abdominal}
dim(datTraits_A)
names(datTraits_A)
# remove columns that hold information we do not need.
allTraits = datTraits_A[, c(1, 4, 5)]
# See how big the traits are and what are the trait and sample names
dim(allTraits)
names(allTraits)
allTraits$sample

# Form a multi-set structure that will hold the clinical traits.
Traits = vector(mode="list", length = nSets);
for (set in 1:nSets)
{
setSamples = rownames(multiExpr_A[[set]]$data);
traitRows = match(setSamples, allTraits$sample);
Traits[[set]] = list(data = allTraits[traitRows,]);
rownames(Traits[[set]]$data) = Traits[[set]]$data$sample;
Traits[[set]]$data = Traits[[set]]$data[,-1]
}
exprSize = checkSets(multiExpr_A)
collectGarbage();
# Define data set dimensions

nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;
nSets = exprSize$nSets;

# assembling table of QUANTITATIVE traits: dummy quantitative variables instead of categorical factor levels:

for (set in 1:nSets)
{
Traits[[set]]$data$Control=as.numeric(Traits[[set]]$data$treatment =="Control");
Traits[[set]]$data$Hyp_T2h=as.numeric(Traits[[set]]$data$treatment =="Hyp_T2h");
Traits[[set]]$data$Hyp_T6h=as.numeric(Traits[[set]]$data$treatment =="Hyp_T6h");
Traits[[set]]$data$Hyp_T5d=as.numeric(Traits[[set]]$data$treatment =="LtH_6");
Traits[[set]]$data$Hyp_T6d=as.numeric(Traits[[set]]$data$treatment =="LtH_7");
Traits[[set]]$data$Reox=as.numeric(Traits[[set]]$data$treatment =="Reox");
Traits[[set]]$data$Recovery=as.numeric(Traits[[set]]$data$treatment =="Recovery");
Traits[[set]]$data <- Traits[[set]]$data[,-c(1:2)]
}

save(multiExpr_A, Traits, nGenes, nSamples, setLabels, shortLabels, exprSize,
file = "gene_expression/data/Consensus-dataInput_Abdominal.RData")

```

```{r prepare trait data pleural}
dim(datTraits_P)
names(datTraits_P)
# remove columns that hold information we do not need.
allTraits = datTraits_P[, c(1, 4, 5)]
# See how big the traits are and what are the trait and sample names
dim(allTraits)
names(allTraits)
allTraits$sample

# Form a multi-set structure that will hold the clinical traits.
Traits = vector(mode="list", length = nSets);
for (set in 1:nSets)
{
setSamples = rownames(multiExpr_P[[set]]$data);
traitRows = match(setSamples, allTraits$sample);
Traits[[set]] = list(data = allTraits[traitRows,]);
rownames(Traits[[set]]$data) = Traits[[set]]$data$sample;
Traits[[set]]$data = Traits[[set]]$data[,-1]
}
exprSize = checkSets(multiExpr_P)
collectGarbage();
# Define data set dimensions

nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;
nSets = exprSize$nSets;

# assembling table of QUANTITATIVE traits: dummy quantitative variables instead of categorical factor levels:

for (set in 1:nSets)
{
Traits[[set]]$data$Control=as.numeric(Traits[[set]]$data$treatment =="Control");
Traits[[set]]$data$Hyp_T2h=as.numeric(Traits[[set]]$data$treatment =="Hyp_T2h");
Traits[[set]]$data$Hyp_T6h=as.numeric(Traits[[set]]$data$treatment =="Hyp_T6h");
Traits[[set]]$data$Hyp_T5d=as.numeric(Traits[[set]]$data$treatment =="LtH_6");
Traits[[set]]$data$Hyp_T6d=as.numeric(Traits[[set]]$data$treatment =="LtH_7");
Traits[[set]]$data$Reox=as.numeric(Traits[[set]]$data$treatment =="Reox");
Traits[[set]]$data$Recovery=as.numeric(Traits[[set]]$data$treatment =="Recovery");
Traits[[set]]$data <- Traits[[set]]$data[,-c(1:2)]
}

save(multiExpr_A, Traits, nGenes, nSamples, setLabels, shortLabels, exprSize,
file = "gene_expression/data/Consensus-dataInput_pleural.RData")
```

```{r prepare data for separate set modules abdominal}

#Abdominal WC first 
load(file = "gene_expression/data/Consensus-dataInput_Abdominal.RData")
datExpr_WC_A = multiExpr_A[[1]]$data

gsg = goodSamplesGenes(datExpr_WC_A, verbose = 3);
gsg$allOK

WC_ASamples = rownames(Traits[[1]]$data);
WC_ATraits = as.data.frame(Traits[[1]]$data)

# Re-cluster samples
sampleTree2 = hclust(dist(datExpr_WC_A), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = labels2colors(datTraits_A[datTraits_A$group == "Wild_cross",]$treatment)

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(WC_ATraits),
main = "Sample dendrogram and trait heatmap")

save(datExpr_WC_A, WC_ATraits, file = "gene_expression/data/WC_A_WGCNA-dataInput.RData")

#Abdominal LC
load(file = "gene_expression/data/Consensus-dataInput_Abdominal.RData")
datExpr_LC_A = multiExpr_A[[2]]$data

gsg = goodSamplesGenes(datExpr_LC_A, verbose = 3);
gsg$allOK

LC_ASamples = rownames(Traits[[2]]$data);
LC_ATraits = as.data.frame(Traits[[2]]$data)

# Re-cluster samples
sampleTree2 = hclust(dist(datExpr_LC_A), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = labels2colors(datTraits_A[datTraits_A$group == "Lab_cross",]$treatment)

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(LC_ATraits),
main = "Sample dendrogram and trait heatmap")

save(datExpr_LC_A, LC_ATraits, file = "gene_expression/data/LC_A_WGCNA-dataInput.RData")

#Pleural WC  
load(file = "gene_expression/data/Consensus-dataInput_pleural.RData")
datExpr_WC_P = multiExpr_P[[1]]$data

gsg = goodSamplesGenes(datExpr_WC_P, verbose = 3);
gsg$allOK

WC_PSamples = rownames(Traits[[1]]$data);
WC_PTraits = as.data.frame(Traits[[1]]$data)

# Re-cluster samples
sampleTree2 = hclust(dist(datExpr_WC_P), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = labels2colors(datTraits_P[datTraits_P$group == "Wild_cross",]$treatment)

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(WC_PTraits),
main = "Sample dendrogram and trait heatmap")

save(datExpr_WC_P, WC_PTraits, file = "gene_expression/data/WC_P_WGCNA-dataInput.RData")

#Abdominal LC
load(file = "gene_expression/data/Consensus-dataInput_pleural.RData")
datExpr_LC_P = multiExpr_P[[2]]$data

gsg = goodSamplesGenes(datExpr_LC_P, verbose = 3);
gsg$allOK

LC_PSamples = rownames(Traits[[2]]$data);
LC_PTraits = as.data.frame(Traits[[2]]$data)

# Re-cluster samples
sampleTree2 = hclust(dist(datExpr_LC_P), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = labels2colors(datTraits_P[datTraits_P$group == "Lab_cross",]$treatment)

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
groupLabels = names(LC_PTraits),
main = "Sample dendrogram and trait heatmap")

save(datExpr_LC_P, LC_PTraits, file = "gene_expression/data/LC_P_WGCNA-dataInput.RData")




```

```{r chose soft threshold Abdominal}
# Wild_cross
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr_WC_A, powerVector = powers, verbose = 5, networkType = "signed")
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

# Lab_cross
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr_LC_A, powerVector = powers, verbose = 5, networkType = "signed")
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

# plot superimposed WC and LC
# Choose a set of soft-thresholding powers
powers = c(seq(4, 10, by = 1), seq(12, 20, by = 2))
# Initialize a list to hold the results of scale-free analysis
powerTables = vector(mode = "list", length = nSets)
# Call the network topology analysis function for each set in turn
for (set in 1:nSets)
  powerTables[[set]] = list(data = pickSoftThreshold(multiExpr_A[[set]]$data, powerVector = powers, verbose = 2, networkType = "signed")[[2]])
collectGarbage()
#Plot the results:
colors = c("black", "red")
# Will plot these columns of the returned scale free analysis tables
plotCols = c(2, 5, 6, 7)
colNames = c(
  "Scale Free Topology Model Fit",
  "Mean connectivity",
  "Median connectivity",
  "Max connectivity"
)
# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4)
for (set in 1:nSets) {
  for (col in 1:length(plotCols)) {
    ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
    ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
  }
}
#Plot the quantities in the chosen columns vs. the soft thresholding power
pdf(file = "gene_expression/output/WGCNA/ScaleFreeTopology_Connectivity_Abdominal.pdf", width = 7, height = 7)
sizeGrWindow(7, 7)
par(mfcol = c(2, 2))
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7
for (col in 1:length(plotCols))
  for (set in 1:nSets) {
    if (set == 1) {
      plot(
        powerTables[[set]]$data[, 1],-sign(powerTables[[set]]$data[, 3]) * powerTables[[set]]$data[, 2],
        xlab = "Soft Threshold (power)",
        ylab = colNames[col],
        type = "n",
        ylim = ylim[, col],
        main = colNames[col]
      )
      addGrid()

    }
    
    if (col == 1) {
      text(
        powerTables[[set]]$data[, 1],-sign(powerTables[[set]]$data[, 3]) * powerTables[[set]]$data[, 2],
        labels = powers,
        cex = cex1,
        col = colors[set]
      )
    } else
      text(
      powerTables[[set]]$data[, 1],
      powerTables[[set]]$data[, plotCols[col]],
      labels = powers,
      cex = cex1,
      col = colors[set]
    )
    if (col == 1) {
      legend("bottomright",
             legend = setLabels,
             col = colors,
             pch = 20)
    } else
      legend("topright",
                 legend = setLabels,
                 col = colors,
                 pch = 20)
  }
dev.off()

```
```{r chose soft threshold Pleural}
# Wild_cross
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr_WC_P, powerVector = powers, verbose = 5, networkType = "signed")
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

# Lab_cross
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr_LC_P, powerVector = powers, verbose = 5, networkType = "signed")
# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

# plot superimposed WC and LC
# Choose a set of soft-thresholding powers
powers = c(seq(4, 10, by = 1), seq(12, 20, by = 2))
# Initialize a list to hold the results of scale-free analysis
powerTables = vector(mode = "list", length = nSets)
# Call the network topology analysis function for each set in turn
for (set in 1:nSets)
  powerTables[[set]] = list(data = pickSoftThreshold(multiExpr_P[[set]]$data, powerVector = powers, verbose = 2, networkType = "signed")[[2]])
collectGarbage()
#Plot the results:
colors = c("black", "red")
# Will plot these columns of the returned scale free analysis tables
plotCols = c(2, 5, 6, 7)
colNames = c(
  "Scale Free Topology Model Fit",
  "Mean connectivity",
  "Median connectivity",
  "Max connectivity"
)
# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4)
for (set in 1:nSets) {
  for (col in 1:length(plotCols)) {
    ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
    ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
  }
}
#Plot the quantities in the chosen columns vs. the soft thresholding power
pdf(file = "gene_expression/output/WGCNA/ScaleFreeTopology_Connectivity_Pleural.pdf", width = 7, height = 7)
sizeGrWindow(7, 7)
par(mfcol = c(2, 2))
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7
for (col in 1:length(plotCols))
  for (set in 1:nSets) {
    if (set == 1) {
      plot(
        powerTables[[set]]$data[, 1],-sign(powerTables[[set]]$data[, 3]) * powerTables[[set]]$data[, 2],
        xlab = "Soft Threshold (power)",
        ylab = colNames[col],
        type = "n",
        ylim = ylim[, col],
        main = colNames[col]
      )
      addGrid()

    }
    
    if (col == 1) {
      text(
        powerTables[[set]]$data[, 1],-sign(powerTables[[set]]$data[, 3]) * powerTables[[set]]$data[, 2],
        labels = powers,
        cex = cex1,
        col = colors[set]
      )
    } else
      text(
      powerTables[[set]]$data[, 1],
      powerTables[[set]]$data[, plotCols[col]],
      labels = powers,
      cex = cex1,
      col = colors[set]
    )
    if (col == 1) {
      legend("bottomright",
             legend = setLabels,
             col = colors,
             pch = 20)
    } else
      legend("topright",
                 legend = setLabels,
                 col = colors,
                 pch = 20)
  }
dev.off()

```
<!--Pick soft threshold function-->
```{r include=FALSE}

plotSoftThreshold <- function(datExpr){
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  # Call the network topology analysis function
  sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5, networkType = "signed")
  # Plot the results:
  sizeGrWindow(9, 5)
  par(mfrow = c(1,2));
  cex1 = 0.9;
  # Scale-free topology fit index as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
       main = paste("Scale independence"));
  text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
       labels=powers,cex=cex1,col="red");
  # this line corresponds to using an R^2 cut-off of h
  abline(h=0.90,col="red", lty = 1)
  abline(h=0.80,col="red", lty = 2)
  # Mean connectivity as a function of the soft-thresholding power
  plot(sft$fitIndices[,1], sft$fitIndices[,5],
       xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
       main = paste("Mean connectivity"))
  text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
}

```

#get TOM for Abdominal
## Wild Cross

```{r}
lnames = load(file = "gene_expression/data/WC_A_WGCNA-dataInput.RData")
lnames

plotSoftThreshold(datExpr_WC_A)
```

###Adjacencies and TOM
```{r TOM abdominal WC, fig.width= 6, fig.height=6, eval = FALSE}
softPower = 8  
adjacency = adjacency(datExpr_WC_A, power = softPower, type = "signed", corFnc = "bicor", corOptions = list(maxPOutliers = 0.1))
TOM = TOMsimilarity(adjacency, TOMType = "signed")
save(TOM, softPower, file = "gene_expression/data/WC_Abdominal_TOM.R")

##Plot TOM
dissTOM = 1 - TOM
nGenes = nrow(TOM)

nSelect = 500
# For reproducibility, we set the random seed
set.seed(10)
select = sample(nGenes, size = nSelect)
selectTOM = dissTOM[select, select]
# There's no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = hclust(as.dist(selectTOM), method = "average")
#selectColors = moduleColors[select]
# Open a graphical window
#sizeGrWindow(9,9)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^7
diag(plotDiss) = NA
pdf(file = "gene_expression/output/WGCNA/WC_Abdominal_TOM_Heatmap.pdf")
TOMplot(plotDiss, selectTree, main = "Network heatmap plot, selected genes", terrainColors = FALSE)
dev.off()

##Clear the data
rm(softPower, adjacency, TOM, datExpr_WC_A, WC_ATraits, dissTOM, plotDiss, selectTOM, selectTree)

```

## Lab Cross
```{r}
lnames = load(file = "gene_expression/data/LC_A_WGCNA-dataInput.RData")
lnames

plotSoftThreshold(datExpr_LC_A)
```

###Adjacencies and TOM
```{r TOM abdominal LC, fig.width= 6, fig.height=6, eval = FALSE}
softPower = 7  
adjacency = adjacency(datExpr_LC_A, power = softPower, type = "signed", corFnc = "bicor", corOptions = list(maxPOutliers = 0.1))
TOM = TOMsimilarity(adjacency, TOMType = "signed")
save(TOM, softPower, file = "gene_expression/data/LC_Abdominal_TOM.R")

##Plot TOM
dissTOM = 1 - TOM
nGenes = nrow(TOM)

nSelect = 500
# For reproducibility, we set the random seed
set.seed(10)
select = sample(nGenes, size = nSelect)
selectTOM = dissTOM[select, select]
# There's no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = hclust(as.dist(selectTOM), method = "average")
#selectColors = moduleColors[select]
# Open a graphical window
#sizeGrWindow(9,9)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^7
diag(plotDiss) = NA
pdf(file = "gene_expression/output/WGCNA/LC_Abdominal_TOM_Heatmap.pdf")
TOMplot(plotDiss, selectTree, main = "Network heatmap plot, selected genes", terrainColors = FALSE)
dev.off()

##Clear the data
rm(softPower, adjacency, TOM, datExpr_LC_A, LC_ATraits, dissTOM, plotDiss, selectTOM, selectTree)

```

#get TOM for Pleural
## Wild Cross
```{r}
lnames = load(file = "gene_expression/data/WC_P_WGCNA-dataInput.RData")
lnames

plotSoftThreshold(datExpr_WC_P)
```

###Adjacencies and TOM
```{r pleural TOM, fig.width= 6, fig.height=6, eval = FALSE}

softPower = 14  
adjacency = adjacency(datExpr_WC_P, power = softPower, type = "signed", corFnc = "bicor", corOptions = list(maxPOutliers = 0.1))

TOM = TOMsimilarity(adjacency, TOMType = "signed")
save(TOM, softPower, file = "gene_expression/data/WC_Pleural_TOM.R")

#lnames = load(file = "data/Pleural_TOM.R")
#lnames

dissTOM = 1 - TOM
nGenes = nrow(TOM)

nSelect = 500
# For reproducibility, we set the random seed
set.seed(10)
select = sample(nGenes, size = nSelect)
selectTOM = dissTOM[select, select]
# There's no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = hclust(as.dist(selectTOM), method = "average")
#selectColors = moduleColors[select]
# Open a graphical window
#sizeGrWindow(9,9)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^7
diag(plotDiss) = NA
pdf(file = "gene_expression/output/WGCNA/WC_Pleural_TOM_Heatmap.pdf")
TOMplot(plotDiss, selectTree, main = "Network heatmap plot, selected genes", terrainColors = FALSE)
dev.off()

##Clear the data
rm(softPower, adjacency, TOM, datExpr_WC_P, WC_PTraits,dissTOM, plotDiss, selectTOM, selectTree)
```

## Wild Cross
```{r}
lnames = load(file = "gene_expression/data/LC_P_WGCNA-dataInput.RData")
lnames

plotSoftThreshold(datExpr_LC_P)
```

###Adjacencies and TOM
```{r pleural TOM, fig.width= 6, fig.height=6, eval = FALSE}

softPower = 14  
adjacency = adjacency(datExpr_LC_P, power = softPower, type = "signed", corFnc = "bicor", corOptions = list(maxPOutliers = 0.1))

TOM = TOMsimilarity(adjacency, TOMType = "signed")
save(TOM, softPower, file = "gene_expression/data/LC_Pleural_TOM.R")

#lnames = load(file = "data/Pleural_TOM.R")
#lnames

dissTOM = 1 - TOM
nGenes = nrow(TOM)

nSelect = 500
# For reproducibility, we set the random seed
set.seed(10)
select = sample(nGenes, size = nSelect)
selectTOM = dissTOM[select, select]
# There's no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = hclust(as.dist(selectTOM), method = "average")
#selectColors = moduleColors[select]
# Open a graphical window
#sizeGrWindow(9,9)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^7
diag(plotDiss) = NA
pdf(file = "gene_expression/output/WGCNA/LC_Pleural_TOM_Heatmap.pdf")
TOMplot(plotDiss, selectTree, main = "Network heatmap plot, selected genes", terrainColors = FALSE)
dev.off()

##Clear the data
rm(softPower, adjacency, TOM, datExpr_LC_P, LC_PTraits,dissTOM, plotDiss, selectTOM, selectTree)
```
# Build Consesus TOM
# A_WC vs A_LC
##Load data and bild TOM list
```{r}
lnames = load(file = "gene_expression/data/WC_Abdominal_TOM.R")
TOM_WC_A <- TOM

lnames = load(file = "gene_expression/data/LC_Abdominal_TOM.R")
TOM_LC_A <- TOM

rm(TOM)

nGenes = nrow(TOM_WC_A)
nSets = 2

#Combine TOMs
#Initialize an appropriate array to hold the TOMs
TOM = array(0, dim = c(2, nGenes, nGenes))
# Calculate TOMs in each individual data set

TOM[1, , ] = TOM_WC_A
TOM[2, , ] = TOM_LC_A

rm(TOM_WC_A,TOM_LC_A)
```

##Scaling TOM overlap
```{r}
# Define the reference percentile
scaleP = 0.95
# Set RNG seed for reproducibility of sampling
set.seed(12345)
# Sample sufficiently large number of TOM entries
nSamples = as.integer(1/(1-scaleP) * 1000)
# Choose the sampled TOM entries
scaleSample = sample(nGenes*(nGenes-1)/2, size = nSamples)
TOMScalingSamples = list()
# These are TOM values at reference percentile
scaleQuant = rep(1, nSets)
# Scaling powers to equalize reference TOM values
scalePowers = rep(1, nSets)
# Loop over sets
for (set in 1:nSets){
  # Select the sampled TOM entries
  TOMScalingSamples[[set]] = as.dist(TOM[set, , ])[scaleSample]
  # Calculate the 95th percentile
  scaleQuant[set] = quantile(TOMScalingSamples[[set]],probs = scaleP, type = 8)
  # Scale the male TOM
  if (set>1){scalePowers[set] = log(scaleQuant[1])/log(scaleQuant[set]);TOM[set, ,] = TOM[set, ,]^scalePowers[set]
  }
  }

```

##qunatile plot
```{r}

# For plotting, also scale the sampled TOM entries
scaledTOMSamples = list()
for (set in 1:nSets)scaledTOMSamples[[set]] = TOMScalingSamples[[set]]^scalePowers[set]
# Open a suitably sized graphics window
sizeGrWindow(6,6)
#pdf(file = "gene_expression/output/WGCNA/TOMScaling-QQPlot_Abdominal.pdf", wi = 6, he = 6)
#qq plot of the unscaled samples
qqUnscaled = qqplot(TOMScalingSamples[[1]], TOMScalingSamples[[2]], plot.it = TRUE, cex = 0.6
                    ,xlab = paste("TOM in", "Wild_cross"), ylab = paste("TOM in", "Lab_cross"),
                    main = "Q-Q plot of TOM for Abdominal ganglion", pch = 20)
# qq plot of the scaled samples
qqScaled = qqplot(scaledTOMSamples[[1]], scaledTOMSamples[[2]], plot.it = FALSE)
points(qqScaled$x, qqScaled$y, col = "red", cex = 0.6, pch = 20)
abline(a=0, b=1, col = "blue")
legend("topleft", legend = c("Unscaled TOM", "Scaled TOM"), pch = 20, col = c("black", "red"))
#dev.off()

```

##build concensus
```{r}
consensusTOM = pmin(TOM[1, , ], TOM[2, , ])
rm(TOM)

save(consensusTOM, file = "gene_expression/data/Consensus_TOM_manual_Abdominal.R")
```

#clustering
```{r}

#lnames = load(file = "../data/r_data/Consensus_TOM.R")

# Clustering
consTree = hclust(as.dist(1-consensusTOM), method = "average")
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;
# Module identification using dynamic tree cut:
unmergedLabels = cutreeDynamic(dendro = consTree, distM = 1-consensusTOM,
deepSplit = 2, cutHeight = 0.995,
minClusterSize = minModuleSize,
pamRespectsDendro = FALSE );
unmergedColors = labels2colors(unmergedLabels)


rm(consensusTOM)
save(unmergedColors, unmergedLabels, consTree, file = "gene_expression/data/Consensus-unmergedCons_Abdominal.R")


```
##check the plot
```{r}
#pdf(file = "output/consensus_dendro_unmerged.pdf", wi = 6, he = 6)
plotDendroAndColors(consTree, unmergedColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()
```

##get multi-Expr
```{r}
lnames = load(file = "gene_expression/data/Consensus-dataInput_Abdominal.RData")

nGenes = exprSize$nGenes
nSamples = exprSize$nSamples

```
##merging modules
```{r}
# Calculate module eigengenes
unmergedMEs = multiSetMEs(multiExpr_A, colors = NULL, universalColors = unmergedColors)
# Calculate consensus dissimilarity of consensus module eigengenes
consMEDiss = consensusMEDissimilarity(unmergedMEs);
# Cluster consensus modules
consMETree = hclust(as.dist(consMEDiss), method = "average");
# Plot the result
#pdf(file = "gene_expression/output/WGCNA/consensus_eigengenes_unmerged_Abdominal.pdf", wi = 7, he = 6)
sizeGrWindow(7,6)
par(mfrow = c(1,1))
plot(consMETree, main = "Consensus clustering of consensus module eigengenes Abdominal WC vs LC",
xlab = "", sub = "")
abline(h=0.4, col = "red")
#dev.off()

merge = mergeCloseModules(multiExpr_A, unmergedLabels, cutHeight = 0.4, verbose = 3)

# Numeric module labels
moduleLabels = merge$colors
# Convert labels to colors
moduleColors = labels2colors(moduleLabels)
# Eigengenes of the new merged modules:
consMEs = merge$newMEs

#pdf(file = "gene_expression/output/WGCNA/consensus_eigengenes_merged_vs_unmerged_Abdominal.pdf", wi = 7, he = 6)
plotDendroAndColors(consTree, cbind(unmergedColors, moduleColors),
c("Unmerged", "Merged"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()

save(consMEs, moduleColors, moduleLabels, consTree, file = "gene_expression/data/Consensus_NetworkConstruction_man_Abdominal.R")
```

# P_WC vs P_LC
##Load data and bild TOM list
```{r}
lnames = load(file = "gene_expression/data/WC_Pleural_TOM.R")
TOM_WC_P <- TOM

lnames = load(file = "gene_expression/data/LC_Pleural_TOM.R")
TOM_LC_P <- TOM

rm(TOM)

nGenes = nrow(TOM_WC_P)
nSets = 2

#Combine TOMs
#Initialize an appropriate array to hold the TOMs
TOM = array(0, dim = c(2, nGenes, nGenes))
# Calculate TOMs in each individual data set

TOM[1, , ] = TOM_WC_P
TOM[2, , ] = TOM_LC_P

rm(TOM_WC_P,TOM_LC_P)
```

##Scaling TOM overlap
```{r}
# Define the reference percentile
scaleP = 0.95
# Set RNG seed for reproducibility of sampling
set.seed(12345)
# Sample sufficiently large number of TOM entries
nSamples = as.integer(1/(1-scaleP) * 1000)
# Choose the sampled TOM entries
scaleSample = sample(nGenes*(nGenes-1)/2, size = nSamples)
TOMScalingSamples = list()
# These are TOM values at reference percentile
scaleQuant = rep(1, nSets)
# Scaling powers to equalize reference TOM values
scalePowers = rep(1, nSets)
# Loop over sets
for (set in 1:nSets){
  # Select the sampled TOM entries
  TOMScalingSamples[[set]] = as.dist(TOM[set, , ])[scaleSample]
  # Calculate the 95th percentile
  scaleQuant[set] = quantile(TOMScalingSamples[[set]],probs = scaleP, type = 8)
  # Scale the male TOM
  if (set>1){scalePowers[set] = log(scaleQuant[1])/log(scaleQuant[set]);TOM[set, ,] = TOM[set, ,]^scalePowers[set]
  }
  }

```

##qunatile plot
```{r}

# For plotting, also scale the sampled TOM entries
scaledTOMSamples = list()
for (set in 1:nSets)scaledTOMSamples[[set]] = TOMScalingSamples[[set]]^scalePowers[set]
# Open a suitably sized graphics window
sizeGrWindow(6,6)
pdf(file = "gene_expression/output/WGCNA/TOMScaling-QQPlot_Pleural.pdf", wi = 6, he = 6)
#qq plot of the unscaled samples
qqUnscaled = qqplot(TOMScalingSamples[[1]], TOMScalingSamples[[2]], plot.it = TRUE, cex = 0.6
                    ,xlab = paste("TOM in", "Wild_cross"), ylab = paste("TOM in", "Lab_cross"),
                    main = "Q-Q plot of TOM for Pleural ganglion", pch = 20)
# qq plot of the scaled samples
qqScaled = qqplot(scaledTOMSamples[[1]], scaledTOMSamples[[2]], plot.it = FALSE)
points(qqScaled$x, qqScaled$y, col = "red", cex = 0.6, pch = 20)
abline(a=0, b=1, col = "blue")
legend("topleft", legend = c("Unscaled TOM", "Scaled TOM"), pch = 20, col = c("black", "red"))
dev.off()

```

##build concensus
```{r}
consensusTOM = pmin(TOM[1, , ], TOM[2, , ])
rm(TOM)

save(consensusTOM, file = "gene_expression/data/Consensus_TOM_manual_Pleural.R")
```

#clustering
```{r}
# Clustering
consTree = hclust(as.dist(1-consensusTOM), method = "average")
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;
# Module identification using dynamic tree cut:
unmergedLabels = cutreeDynamic(dendro = consTree, distM = 1-consensusTOM,
deepSplit = 2, cutHeight = 0.995,
minClusterSize = minModuleSize,
pamRespectsDendro = FALSE );
unmergedColors = labels2colors(unmergedLabels)


rm(consensusTOM)
save(unmergedColors, unmergedLabels, consTree, file = "gene_expression/data/Consensus-unmergedCons_Pleural.R")


```
##check the plot
```{r}
#pdf(file = "output/consensus_dendro_unmerged.pdf", wi = 6, he = 6)
plotDendroAndColors(consTree, unmergedColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()
```

##get multi-Expr
```{r}
lnames = load(file = "gene_expression/data/Consensus-dataInput_pleural.RData")

nGenes = exprSize$nGenes
nSamples = exprSize$nSamples

```
##merging modules
```{r}
# Calculate module eigengenes
unmergedMEs = multiSetMEs(multiExpr_P, colors = NULL, universalColors = unmergedColors)
# Calculate consensus dissimilarity of consensus module eigengenes
consMEDiss = consensusMEDissimilarity(unmergedMEs);
# Cluster consensus modules
consMETree = hclust(as.dist(consMEDiss), method = "average");
# Plot the result
#pdf(file = "gene_expression/output/WGCNA/consensus_eigengenes_unmerged_Pleural.pdf", wi = 7, he = 6)
sizeGrWindow(7,6)
par(mfrow = c(1,1))
plot(consMETree, main = "Consensus clustering of consensus module eigengenes Pleura; WC vs LC",
xlab = "", sub = "")
abline(h=0.5, col = "red")
#dev.off()

merge = mergeCloseModules(multiExpr_P, unmergedLabels, cutHeight = 0.5, verbose = 3)

# Numeric module labels
moduleLabels = merge$colors
# Convert labels to colors
moduleColors = labels2colors(moduleLabels)
# Eigengenes of the new merged modules:
consMEs = merge$newMEs

#pdf(file = "gene_expression/output/WGCNA/consensus_eigengenes_merged_vs_unmerged_Pleural.pdf", wi = 7, he = 6)
plotDendroAndColors(consTree, cbind(unmergedColors, moduleColors),
c("Unmerged", "Merged"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()

save(consMEs, moduleColors, moduleLabels, consTree, file = "gene_expression/data/Consensus_NetworkConstruction_man_Pleural.R")
```

# Module analysis
```{r}
library(ComplexHeatmap)
library(circlize)
library(ggplot2)
library(RColorBrewer)
library(cowplot)

#Define function to summarize count table to a group level

summarize_group <- function(ma, group){
    counts_group = t(sapply(rownames(ma), function(g){
        sapply(levels(group), function(i){
            idx = which(group == i)
            mean(ma[g, idx], na.rm = TRUE)
        })
    }))
    colnames(counts_group) = levels(group)
    counts_group
}
```

#Abdominal
```{r, echo=FALSE, message=FALSE, warning = FALSE, fig.width=10, fig.height=7}

load(file = "gene_expression/data/Consensus-dataInput_Abdominal.RData")
load(file = "gene_expression/data/Consensus_NetworkConstruction_man_Abdominal.R")


exprDat <- t(rbind(multiExpr_A[[1]]$data, multiExpr_A[[2]]$data))
gene2module <- data.frame(gene = rownames(exprDat), module = moduleColors, stringsAsFactors = FALSE)
write.csv(x = gene2module, file = "gene_expression/output/WGCNA/Concensus_gene2module_Abdominal.csv", quote = FALSE)

## Relate ME to external traits for each individual set
exprSize = checkSets(multiExpr_A)
nSets = exprSize$nSets;

# Set up variables to contain the module-trait correlations
moduleTraitCor = list();
moduleTraitPvalue = list();

# Calculate the correlations
for (set in 1:nSets)
{
moduleTraitCor[[set]] = cor(consMEs[[set]]$data, Traits[[set]]$data, use = "p");
moduleTraitPvalue[[set]] = corPvalueFisher(moduleTraitCor[[set]], exprSize$nSamples[set]);
}

# Convert numerical lables to colors for labeling of modules in the plot
MEColors = labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)));
MEColorNames = paste("ME", MEColors, sep="");
# Open a suitably sized window (the user should change the window size if necessary)

#pdf(file = "figures/ModuleTraitRelationships_by_tissue.pdf", wi = 16, he = 7);
# Plot the module-trait relationship table for set number 1

par(mfrow = c(1,2))

set = 1
textMatrix = paste(signif(moduleTraitCor[[set]], 2), "\n(",
signif(moduleTraitPvalue[[set]], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor[[set]])

par(mar = c(6, 8.8, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitCor[[set]],
xLabels = names(Traits[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module-trait relationships", setLabels[set]))


# Plot the module-trait relationship table for set number 2
set = 2
textMatrix = paste(signif(moduleTraitCor[[set]], 2), "\n(",
signif(moduleTraitPvalue[[set]], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor[[set]])

#pdf(file = "gene_expression/output/WGCNA/ModuleTraitRelationships-Abdominal.pdf", wi = 10, he = 7);
par(mar = c(6, 8.8, 3, 2.2));

labeledHeatmap(Matrix = moduleTraitCor[[set]],
xLabels = names(Traits[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),

main = paste("Module-trait relationships", setLabels[set]))

dev.off()

par(mfrow = c(1,1))

```

## Relate ME to traits in concensus set
```{r, echo=FALSE, message=FALSE, warning = FALSE, fig.width=8, fig.height=8}
# Initialize matrices to hold the consensus correlation and p-value
consensusCor = matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]));
consensusPvalue = matrix(NA, nrow(moduleTraitCor[[1]]), ncol(moduleTraitCor[[1]]));
# Find consensus negative correlations
negative = moduleTraitCor[[1]] < 0 & moduleTraitCor[[2]] < 0;
consensusCor[negative] = pmax(moduleTraitCor[[1]][negative], moduleTraitCor[[2]][negative]);
consensusPvalue[negative] = pmax(moduleTraitPvalue[[1]][negative], moduleTraitPvalue[[2]][negative]);
# Find consensus positive correlations
positive = moduleTraitCor[[1]] > 0 & moduleTraitCor[[2]] > 0;
consensusCor[positive] = pmin(moduleTraitCor[[1]][positive], moduleTraitCor[[2]][positive]);
consensusPvalue[positive] = pmax(moduleTraitPvalue[[1]][positive], moduleTraitPvalue[[2]][positive]);

textMatrix = paste(signif(consensusCor, 2), "\n(",
signif(consensusPvalue, 1), ")", sep = "");
textMatrix <-textMatrix %>% str_replace_all(string =., pattern = "NA\\n\\(NA\\)", replacement = "No Concensus")
dim(textMatrix) = dim(moduleTraitCor[[set]])


#pdf(file = "gene_expression/output/WGCNA/ModuleTraitRelationships_consensus_Abdominal.pdf", wi = 9, he = 6);
par(mar = c(2, 6, 3, 2.2));
labeledHeatmap(Matrix = consensusCor, 
               xLabels = names(Traits[[set]]$data),
               yLabels = MEColorNames,
               ySymbols = stringr::str_remove(MEColorNames, "ME"),
               colorLabels = TRUE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               cex.lab = 0.75,
               xLabelsAngle = 0,
               xLabelsAdj = 0.5,
               zlim = c(-1,1),
               main = paste("Consensus module--trait relationships across\n",
                            paste(setLabels, collapse = " and "))
               )
#dev.off()

```
# Comparing eigengene networks
```{r eigenegene comparizon_Abdominal, fig.width=12, fig.height= 14}

# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr_A, universalColors = moduleColors);
# We add the weight trait to the eigengenes and order them by consesus hierarchical clustering:
#MET = consensusOrderMEs(addTraitToMEs(consMEsC, Traits));
MET = consensusOrderMEs(consMEsC);
# We now call the function plotEigengeneNetworks that performs the differential analysis:
sizeGrWindow(12,14);
#pdf(file = "gene_expression/output/WGCNA/ConsensusEigengeneNetworks_Abdominal.pdf", width= 12, height = 14);
par(cex = 1.2)
plotEigengeneNetworks(MET,  
                      setLabels,
                      printAdjacency = FALSE,
                      colorLabels = TRUE,
                      barplotErrors = TRUE,
                      Letters = TRUE,
                      signed = TRUE,
                      excludeGrey = TRUE, 
                      plotHeatmaps = TRUE,
                      marDendro = c(0,2,2,1), 
                      marHeatmap = c(3,3,1,1),
                      zlimPreservation = c(0.2, 1), 
                      xLabelsAngle = 90)
#dev.off();
```
# Eigenegene differential expression 
```{r}
eigengenes_wild <- consMEsC[[1]]$data  # Eigengenes for condition 1
eigengenes_lab <- consMEsC[[2]]$data  # Eigengenes for condition 2

# Combine into a single data frame with condition and treatment metadata
eigengenes_combined <- rbind(
  data.frame(eigengenes_wild), data.frame(eigengenes_lab)
)

eigengenes_combined <- t(eigengenes_combined)

# Metadata for samples
sdat <- read_csv("gene_expression/data/sample_metadata.csv")
sdat$treatment <- gsub("C", "Control", sdat$treatment)
sdat$treatment <- gsub("LtH_6", "Hyp_T5d", sdat$treatment)
sdat$treatment <- gsub("LtH_7", "Hyp_T6d", sdat$treatment)
sdat$batch <- gsub(60, "Lab_cross", sdat$batch)
sdat$batch <- gsub(71, "Wild_cross", sdat$batch)
sdat$group <- factor(paste0(sdat$batch, sdat$treatment))
sdat <- sdat[sdat$sample_ID %in% colnames(eigengenes_combined),]

library(limma)
design <- model.matrix(~ 0 + group, data = sdat)
colnames(design) <- levels(sdat$group)
print(design)


# Fit linear model to the eigengene data
fit <- lmFit(eigengenes_combined, design)

# Specify contrasts to compare Lab vs Wild across treatments
treatments <- unique(sdat$treatment)
contrast_list <- lapply(treatments, function(treatment) {
  paste0("Lab_cross", treatment, " - Wild_cross", treatment)
})
contrast_matrix <- makeContrasts(contrasts = contrast_list, levels = design)
colnames(contrast_matrix) <- treatments

# Apply contrasts
fit2 <- contrasts.fit(fit, contrast_matrix)

# Compute statistics
fit2 <- eBayes(fit2)

# Combine results for all contrasts into a single data frame
results_list <- lapply(treatments, function(treatment) {
  topTable(fit2, coef = treatment, number = Inf, adjust.method = "fdr") %>%
    rownames_to_column(var = "module")
})

# Add treatment labels to results
for (i in seq_along(treatments)) {
  results_list[[i]]$treatment <- treatments[i] 
}

# Combine all results into one table
combined_results <- do.call(rbind, results_list) %>%
  mutate(Significant = ifelse(adj.P.Val < 0.05, "**", "")) 
rownames(combined_results) <- NULL  # Optional: Reset row names

# Draw heatmap with all comparisons

library(ggplot2)

# Create heatmap
DEig_plot <- ggplot(combined_results, aes(x = module, y = factor(treatment, levels = c("Control","Hyp_T2h","Hyp_T6h","Hyp_T5d","Hyp_T6d","Reox","Recovery"), ordered = T), fill = logFC)) +
  geom_tile(color = "white") +  # Heatmap tiles
  geom_text(aes(label = paste0(round(adj.P.Val, 3), Significant)), size = 2) +  # Annotate p-values
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, name = "Log2FC") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title = element_blank()
  );DEig_plot 

ggsave(file = "gene_expression/output/WGCNA/DE_heatmap_consensus_eigengenes_Abdominal.png", DEig_plot, width= 6, height = 4)
```

# Module preservation analysis Abdominal
# Build independent networks for Wild and Lab

```{r}
library(WGCNA)
# The following setting is important, do not omit.
options(stringsAsFactors = FALSE);
# Load the data saved in the first part
lnames = load(file = "gene_expression/data/LC_A_WGCNA-dataInput.RData");
#The variable lnames contains the names of loaded variables.
lnames
lnames = load(file = "gene_expression/data/WC_A_WGCNA-dataInput.RData");
#The variable lnames contains the names of loaded variables.
lnames

#For LabCross
net = blockwiseModules(datExpr_LC_A, power = 7,
                       randomSeed = 54321,
                       TOMType = "signed", minModuleSize = 30,
                       reassignThreshold = 1e-6, mergeCutHeight = 0.4,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = FALSE,
                       verbose = 3)
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

moduleLabels = net$colors
moduleColors = labels2colors(net$colors)
MEs = net$MEs;
geneTree = net$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree,file = "gene_expression/data/labCross_networkConstruction-auto_A.RData")

#For wildCross
net = blockwiseModules(datExpr_WC_A, power = 8,
                       randomSeed = 54321,
                       TOMType = "signed", minModuleSize = 30,
                       reassignThreshold = 1e-6, mergeCutHeight = 0.4,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = FALSE,
                       verbose = 3)
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

moduleLabels = net$colors
moduleColors = labels2colors(net$colors)
MEs = net$MEs;
geneTree = net$dendrograms[[1]];
save(MEs, moduleLabels, moduleColors, geneTree,file = "gene_expression/data/WildCross_networkConstruction-auto_A.RData")
```


```{r}
# load results of wild network analysis
lnames = load("gene_expression/data/labCross_networkConstruction-auto_A.RData")
lnames
# Rename variables to avoid conflicts
labLabels = moduleLabels;
labColors = moduleColors;
labTree = geneTree;
labMEs = orderMEs(MEs, greyName = "ME0");

# load results of wild network analysis
lnames = load("gene_expression/data/WildCross_networkConstruction-auto_A.RData")
lnames
# Rename variables to avoid conflicts
wildLabels = moduleLabels;
wildColors = moduleColors;
wildTree = geneTree;
wildMEs = orderMEs(MEs, greyName = "ME0");

# Load the data saved in the first part
lnames = load(file = "gene_expression/data/Consensus-dataInput_Abdominal.RData");
#The variable lnames contains the names of loaded variables.
lnames

multiExpr_A = list(wild = list(data = multiExpr_A[[1]]$data), lab = list(data = multiExpr_A[[2]]$data))
multiColor_A = list(wild = moduleColors, lab = labColors)
```

# Calculate module preservation of WildCross data in LabCross modules
```{r calculate module preservation}
system.time( {
  mp = modulePreservation(multiExpr_A, multiColor_A,
                        referenceNetworks = c(1, 2), 
                        nPermutations = 200, 
                        randomSeed = 2, 
                        quickCor = 0, 
                        verbose = 3)
  } );

# Save the results
save(mp, file = "gene_expression/output/WGCNA/modulePreservation_A.RData");
```

# Calculate module preservation of WildCross data in LabCross modules
```{r calculate module preservation}
system.time( {
  mp = modulePreservation(multiExpr_A, multiColor_A,
                        referenceNetworks = c(1,2),
                        networkType = "signed",
                        nPermutations = 200, 
                        randomSeed = 1234, 
                        quickCor = 0, 
                        verbose = 3)
  } );

# Save the results
#save(mp, file = "gene_expression/output/WGCNA/modulePreservation_A.RData");
```

# Analysis of module preservation results
```{r calculate module preservation}
load("gene_expression/output/WGCNA/modulePreservation_A.RData")

#Isolate the observed statistics and their Z scores:
ref = 1
test = 2
statsObs = cbind(mp$quality$observed[[ref]][[test]][, -1], mp$preservation$observed[[ref]][[test]][, -1])
statsZ = cbind(mp$quality$Z[[ref]][[test]][, -1], mp$preservation$Z[[ref]][[test]][, -1]);

#We look at the main output: the preservation medianRank and Zsummary statistics.

# Compare preservation to quality:
print( cbind(statsObs[, c("medianRank.pres", "medianRank.qual")],
signif(statsZ[, c("Zsummary.pres", "Zsummary.qual")], 2)) )

modColors = rownames(mp$preservation$observed[[ref]][[test]])
moduleSizes = mp$preservation$Z[[ref]][[test]][, 1];
# leave grey and gold modules out
plotMods = !(modColors %in% c("grey", "gold"));
# Text labels for points
text = modColors[plotMods];
# Auxiliary convenience variable
plotData = cbind(mp$preservation$observed[[ref]][[test]][, 2], mp$preservation$Z[[ref]][[test]][, 2])
# Main titles for the plot
mains = c("Preservation Median rank", "Preservation Zsummary");

# Start the plot
sizeGrWindow(12, 7);
#pdf("gene_expression/output/WGCNA/Abdominal-modulePreservation-Zsummary-medianRank.pdf", wi=10, h=5)
par(mfrow = c(1,2))
par(mar = c(4.5,4.5,2.5,1))
for (p in 1:2)
{
min = min(plotData[, p], na.rm = TRUE);
max = max(plotData[, p], na.rm = TRUE);
# Adjust ploting ranges appropriately
if (p==2)
{
if (min > -max/10) min = -max/10
ylim = c(min - 0.1 * (max-min), max + 0.1 * (max-min))
} else
ylim = c(max + 0.1 * (max-min), min - 0.1 * (max-min))
plot(moduleSizes[plotMods], plotData[plotMods, p], col = 1, bg = modColors[plotMods], pch = 21,
main = mains[p],
cex = 2.4,
ylab = mains[p], xlab = "Module size", log = "x",
ylim = ylim,
xlim = c(30, 2000), cex.lab = 1.2, cex.axis = 1.2, cex.main =1.4)
# add threshold lines
if (p==2)
{
abline(h=0)
abline(h=10, col = "darkgreen", lty = 2)
} else {
abline(h=8, col = "blue", lty = 2)
}
}
# If plotting into a file, close it
#dev.off();

```

## Plot density and conectivity
```{r, fig.width=10, fig.height=8}

# Re-initialize module color labels and sizes
modColors = rownames(statsZ)
moduleSizes = mp$quality$Z[[ref]][[test]][, 1];
# Exclude improper modules
plotMods = !(modColors %in% c("grey", "gold"));
# Create numeric labels for each module
labs = match(modColors[plotMods], standardColors(50));
# Start the plot: open a suitably sized graphical window and set sectioning and margins.
sizeGrWindow(15, 12);
#pdf("output/modulePreservation-fullSummary.pdf", wi=15, h=12)
par(mfrow = c(4,5))
par(mar = c(3,3,2,1))
par(mgp = c(1.6, 0.4, 0));
# Plot each Z statistic in a separate plot.
for (s in 1:ncol(statsZ))
{
min = min(statsZ[plotMods, s], na.rm = TRUE);
max = max(statsZ[plotMods, s], na.rm = TRUE);
if (min > -max/5) min = -max/5
plot(moduleSizes[plotMods], statsZ[plotMods, s], col = 1, bg = modColors[plotMods], pch = 21,
#main = colnames(statsZ)[s],
cex = 1.7,
ylab = colnames(statsZ)[s], xlab = "Module size", log = "x",
ylim = c(min - 0.1 * (max-min), max + 0.1 * (max-min)),
xlim = c(20, 1000))
#labelPoints(moduleSizes[plotMods], statsZ[plotMods, s], labs, cex = 0.7, offs = 0.04);
abline(h=0)
abline(h=2, col = "blue", lty = 2)
abline(h=10, col = "darkgreen", lty = 2)
}

data.frame(color = modColors[plotMods], label = labs)

#dev.off();
```
# output all results
```{r}
# This variable will contain the summary table 
summaryTable=NULL 

exprSize = checkSets(multiExpr_A);
nSets = exprSize$nSets;

# Loop over all combinations of reference and tests sets 
for(ref in 1:nSets) for(test in 1:nSets) if(ref!=test) 
{ 
  modules=rownames(mp$preservation$Z[[ref]][[test]]); 
  nMods=length(modules); 
  sizes=mp$preservation$Z[[ref]][[test]][,1]; 
  acc=matrix(NA,nMods,3); if(test!=4) 
  { 
    acc[match(rownames(mp$accuracy$observed[[ref]][[test]]),modules),]=mp$accuracy$observed[[ref]][[test]][,-1,drop=FALSE]; 
    colnames(acc)=colnames(mp$accuracy$observed[[ref]][[test]])[-1];
    accZ=mp$accuracy$Z[[ref]][[test]][,-1,drop=FALSE];
    acc.log.p=mp$accuracy$log.p[[ref]][[test]][,-1,drop=FALSE];
    acc.log.pBonf=mp$accuracy$log.pBonf[[ref]][[test]][,-1,drop=FALSE]; 
  }
   else
     {
      accZ=matrix(NA,nMods,3); 
      cc.log.p=matrix(NA,nMods,3); 
      acc.log.pBonf=matrix(NA,nMods,3);
      colnames(acc)=colnames(mp$accuracy$observed[[1]][[2]])[-1];
      colnames(accZ)=colnames(mp$accuracy$Z[[1]][[2]])[-1];
      colnames(acc.log.p)=colnames(mp$accuracy$log.p[[1]][[2]])[-1];
      colnames(acc.log.pBonf)=colnames(mp$accuracy$log.pBonf[[1]][[2]])[-1]; 
    } 
# Table of results for this reference-test combination

    tab=cbind(referenceSet=rep(setLabels[ref],nMods), 
          testSet=rep(setLabels[test],nMods), 
          moduleLabel=modules, 
          moduleSize=sizes, 
          mp$quality$observed[[ref]][[test]][,-1,drop=FALSE],
          mp$preservation$observed[[ref]][[test]][,-1,drop=FALSE], 
          acc,
          mp$referenceSeparability$observed[[ref]][[test]][,-1,drop=FALSE],
          mp$testSeparability$observed[[ref]][[test]][,-1,drop=FALSE],
          mp$quality$Z[[ref]][[test]][,-1,drop=FALSE],
          mp$quality$log.p[[ref]][[test]][,-1,drop=FALSE],
          mp$quality$log.pBonf[[ref]][[test]][,-1,drop=FALSE],
          mp$preservation$Z[[ref]][[test]][,-1,drop=FALSE],
          mp$preservation$log.p[[ref]][[test]][,-1,drop=FALSE],
          mp$preservation$log.pBonf[[ref]][[test]][,-1,drop=FALSE], 
          accZ, 
          acc.log.p, 
          acc.log.pBonf, 
          mp$referenceSeparability$Z[[ref]][[test]][,-1,drop=FALSE],
          mp$referenceSeparability$log.p[[ref]][[test]][,-1,drop=FALSE],
          mp$referenceSeparability$log.pBonf[[ref]][[test]][,-1,drop=FALSE],
          mp$testSeparability$Z[[ref]][[test]][,-1,drop=FALSE],
          mp$testSeparability$log.p[[ref]][[test]][,-1,drop=FALSE],
          mp$testSeparability$log.pBonf[[ref]][[test]][,-1,drop=FALSE]
          ) 

# Add the table to the main table.
  if(is.null(summaryTable))
    summaryTable=tab else summaryTable=rbind(summaryTable,tab); 
} 

# Save the table in csv format.

write.table(summaryTable, file="gene_expression/output/WGCNA/WildLab_A-preservation-completeResults.csv",row.names=FALSE, sep=",",quote=FALSE);
```

```{r}
library(flashClust)
dendrograms=list(); 
for(set in 1:nSets) 
{ 
  adj = abs(cor(multiExpr_A[[set]]$data, use="p"))^12; 
  dtom = TOMdist(adj); 
  dendrograms[[set]]=flashClust(as.dist(dtom),method="a"); 
} 

#Get eigengenes 
mes=list() 
for(set in 1:nSets) 
{ 
  mes[[set]]=moduleEigengenes(multiExpr_A[[set]]$data,
                              multiColor_A[[ref]])$eigengenes 
}

```

```{r}

# Calculate the contingency table and p-values
overlap=overlapTable(wildColors,
                     labColors); 

#The numMat will encode color. We use-log of the pvalue. 
numMat=-log10(overlap$pTable); 
numMat[numMat>50]=50; 

#Prepare for generating a color-coded plot of the overlap table. The text of the table will consist of counts and corresponding p-values.

textMat=paste(overlap$countTable,"\n",signif(overlap$pTable,2)); 
dim(textMat)=dim(numMat) 

#Additional information for the plot.
xLabels=paste("M",sort(unique(labColors)));
yLabels=paste("M",sort(unique(wildColors)));
xSymbols=paste(sort(unique(labColors)),":",table(labColors),sep="")
ySymbols=paste(sort(unique(wildColors)),":",table(wildColors),sep="")

```


```{r, fig.width= 10, fig.height=10}

sizeGrWindow(7,7); fp=FALSE;
#pdf("figures/wild_lab_module_overlap.pdf", w=10, h=8.0); 
fp=TRUE 
layout(matrix(c(1,2,5,3,4,5),3,2), 
       heights=c(3,1,5.5),
       widths=c(1,1)); 
#layout.show(5); 
par(mgp=c(3,1,0)); 
plotDendroAndColors(dendrograms[[1]], 
                    cbind(wildColors, labColors), 
                    c("Wild Cross Modules","Lab Cross Modules"), 
                    setLayout=FALSE, 
                    marAll=c(1,6,2.7,0.2), 
                    addGuide=FALSE, 
                    main="Wild Cross gene dendrogram\nand module colors",cex.main=1.2,
                    dendroLabels=FALSE,hang=0.03,cex.colorLabels=0.7,abHeight=0.95);
par(mgp=c(3,1,0)); 
plotDendroAndColors(dendrograms[[2]], 
                    cbind(wildColors, labColors), 
                    c("Wild Cross Modules","Lab Cross Modules"), 
                    setLayout=FALSE, 
                    marAll=c(1,6,2.7,0.2), 
                    addGuide=FALSE, 
                    main="Lab Cross gene dendrogram\nand module colors",cex.main=1.2,
                    dendroLabels=FALSE,hang=0.03,cex.colorLabels=0.7,abHeight=0.95);

# Plot the overlap table 
fcex=1.00; 
pcex=1.0 
fcexl=1.00; 
pcexl=1.00; 
par(mar=c(6,7,2,1.0)); 
labeledHeatmap(Matrix=numMat, 
               xLabels=xLabels,
               xSymbols=xSymbols, 
               yLabels=yLabels,
               ySymbols=ySymbols, 
               colorLabels=TRUE, 
               colors=greenWhiteRed(100)[50:100],
               textMatrix=textMat, cex.text=if(fp) fcex else pcex, setStdMargins=FALSE,
               cex.lab=if(fp) fcexl else pcexl, 
               xColorWidth=0.08,
               main="Wild Cross modules (rows) vs. Lab Cross modules (columns)",cex.main=1.2); #dev.off();
```

```{r}


```


# Calculate adjacency within the salmon module
```{r}
# load annotation 
load(file = "data/annotation/annot.R");
load(file = "data/annotation/AplCalGFF3v1.21_Tabular.R")
eggAnnot <- read.delim("data/annotation/AplCal3_NOG.emapper.annotations", sep = "\t", header = TRUE, skip = 3)

eggAnnot$X.query_name <- gsub("\\..*","",eggAnnot$X.query_name)
colnames(eggAnnot)[1] <- "prot"
annot <- merge(eggAnnot, Complete_AplCal_map, by = "prot", all.y = TRUE)

# Match probes in the data set to the probe IDs in the annotation file
probes = names(multiExpr[[1]]$data)
probes2annot = match(probes, annot$gene)

gene2module <- data.frame(gene = colnames(multiExpr[[1]]$data), module = moduleColors, stringsAsFactors = FALSE)

temp = data.frame(Probe = probes, GeneSymbol = annot$Preferred_name[probes2annot], gene_name = annot$product[probes2annot],
ModuleLabel = moduleLabels,
ModuleColor = labels2colors(moduleLabels)) 

temp <- na.omit(temp)

gene_set <- temp$Probe[which(temp$ModuleColor == "tan")]
nGenes <- length(gene_set)

nSets = 2
pathwayAdjs = list();
for (set in 1:nSets)
{
printFlush(paste("Working on set", setLabels[set]));
bc = bicor(multiExpr[[set]]$data[, gene_set], use = "p");
#bc[bc<0] = 0;
pathwayAdjs[[set]] = abs(bc)^4 * sign(bc);
}
# We order the genes by a weighted average connectivity
conn = matrix(0, nGenes, nSets);
for (set in 1:nSets)
conn[, set] = apply(abs(pathwayAdjs[[set]]), 2, sum)-1
weights = c(3,1,5,1, 3,1,5,1);
wMat = matrix(weights, nGenes, nSets, byrow = TRUE);
wconn = apply(conn * wMat, 1, sum);
order = order(-wconn);
# use the gene names as lables
labels = temp$GeneSymbol[temp$Probe %in% colnames(pathwayAdjs[[ref]])];
# Ordering of pathways:
CPorder = c(1,2);
# Input the R function circlePlot
source("rmd/circlePlot.R");
sizeGrWindow(12,6)
#pdf(file = "Plots/indivPathway-allgenes-GOCholesterolBiosynthesis-circlePlots.pdf", wi=12, h=6.5)
par(mfrow =c(1,2));
for (set in 1:nSets)
{
circlePlot(pathwayAdjs[[CPorder[set]]], labels, order, main = setLabels[CPorder[set]],
variable.cex.labels = TRUE,
radii = c(0.56, 0.62), center = c(0.1, 0.04),
min.cex.labels = 1.2, max.cex.labels = 1.4, cex.main = 1.4);
}
# If plotting into a file, close it
#dev.off();
```

