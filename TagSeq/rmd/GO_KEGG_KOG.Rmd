---
title: "Functional Enrichment WGCNA clusters"
author: "Javier Rodriguez Casariego"
date: '2022-10-01'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Volumes/JARC_2T/NSF-CREST_Postdoc/LongTerm_Hypoxia_exp/AplCal_hypoxia/TagSeq/analyses/GO_MWU_WGCNA/')
```

```{r}
source("gomwu.functions.R")
library(dplyr)
library(tidyr)
library(kableExtra)
library(tidyverse)
```

### Gene Ontology Analysis of each module cluster obtained from WGCNA

```{r GO_MWU for significant modules "all tissues"}

# GO_MWU uses continuous measure of significance (such as fold-change or -log(p-value) ) to identify GO categories that are significantly enriches with either up- or down-regulated genes. The advantage - no need to impose arbitrary significance cutoff.

# If the measure is binary (0 or 1) the script will perform a typical "GO enrichment" analysis based Fisher's exact test: it will show GO categories over-represented among the genes that have 1 as their measure. 

# On the plot, different fonts are used to indicate significance and color indicates enrichment with either up (red) or down (blue) regulated genes. No colors are shown for binary measure analysis.

# The tree on the plot is hierarchical clustering of GO categories based on shared genes. Categories with no branch length between them are subsets of each other.

# The fraction next to GO category name indicates the fracton of "good" genes in it; "good" genes being the ones exceeding the arbitrary absValue cutoff (option in gomwuPlot). For Fisher's based test, specify absValue=0.5. This value does not affect statistics and is used for plotting only.

# Stretch the plot manually to match tree to text

# Mikhail V. Matz, UT Austin, February 2015; matz@utexas.edu

# Edited by J Rodriguez-Casariego, Oct 2022


file.list <- list.files(path = "input/", pattern = "*.csv")
goDivisions <- c("BP", "MF", "CC")
goAnnotations="seq2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml

# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
for(input in file.list[c(8,9,11)]) {
  for (division in goDivisions) {
    gomwuStats(input, goDatabase, goAnnotations, division,
               perlPath="/usr/bin/perl", # replace with full path to perl executable 
               largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
               smallest=5,   # a GO category should contain at least this many genes to be considered
               clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for 
               Module=TRUE, Alternative="g", # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.
    
  }
} 

```

```{r}

# Get list of all significant GO terms for cluster

all_Cl1.GO <- as.list(
  c(BP = "MWU_BP_all_blue.csv",
    MF = "MWU_MF_all_blue.csv",
    CC = "MWU_CC_all_blue.csv")
  ) %>% map(read.table, header = T) %>%
  bind_rows(.id = "ontology") %>%
  as_tibble() %>%
  filter(p.adj < 0.01) %>%
  select(ontology, nseqs, name, delta.rank, p.adj)
# Get list of individual genes with GO annotations and p-values for contrast
all_Cl1.genepvals <- as.list(
  c(BP = "BP_all_blue.csv",
    MF = "MF_all_blue.csv",
    CC = "CC_all_blue.csv")
  ) %>% map(read_tsv) %>%
  bind_rows(.id = "ontology")
# For all significant GO terms, count how many genes with that GO term have raw pvalue < 0.05 (= "nsig")
all_Cl1.GO <- all_Cl1.GO %>%
  mutate(nsig = map_dbl(name, function(.) {
    filter(all_Cl1.genepvals, name == ., -abs(value) <= log10(0.05)) %>%
    nrow(.)
  }))
  
# Print table
(gotable <- all_Cl1.GO %>%
  unite("genes", nsig, nseqs, sep = "/") %>%
  arrange(ontology, delta.rank) %>%
  knitr::kable())
write_tsv(all_Cl1.GO %>%
  unite("genes", nsig, nseqs, sep = "/") %>%
  arrange(ontology, delta.rank), "../../output/all_Cl1_goout.txt")
```

# Run Matz code to create gomwuplot
```{r}
# Run Matz code to create gomwuplot
bp <- gomwuPlot(inFile = "all_blue.csv", 
   goDivision = "BP", goAnnotations = "seq2go.tab")
cc <- gomwuPlot(inFile = "all_blue.csv", 
   goDivision = "CC", goAnnotations = "seq2go.tab")
mf <- gomwuPlot(inFile = "all_blue.csv", 
   goDivision = "MF", goAnnotations = "seq2go.tab")
```

```{r GO_MWU for abdominal module}

file.list <- list.files(path = "input/", pattern = "*.csv")
goDivisions <- c("BP", "MF", "CC")
goAnnotations="seq2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml

# Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previos runs first.
for(input in file.list[c(5:6)]) {
  for (division in goDivisions) {
    gomwuStats(input, goDatabase, goAnnotations, division,
               perlPath="/usr/bin/perl", # replace with full path to perl executable 
               largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
               smallest=5,   # a GO category should contain at least this many genes to be considered
               clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for 
               Module=TRUE, Alternative="g", # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.
    
  }
} 


# Get list of all significant GO terms for contrast
plum.GO <- as.list(
  c(BP = "data/GO_MWU/MWU_BP_plum.csv",
    MF = "data/GO_MWU/MWU_MF_plum.csv",
    CC = "data/GO_MWU/MWU_CC_plum.csv")
  ) %>% map(read.table, header = T) %>%
  bind_rows(.id = "ontology") %>%
  as_tibble() %>%
  filter(p.adj < 0.01) %>%
  select(ontology, nseqs, name, delta.rank, p.adj)
# Get list of individual genes with GO annotations and p-values for contrast
plum.genepvals <- as.list(
  c(BP = "data/GO_MWU/BP_plum.csv",
    MF = "data/GO_MWU/MF_plum.csv",
    CC = "data/GO_MWU/CC_plum.csv")
  ) %>% map(read_tsv) %>%
  bind_rows(.id = "ontology")
# For all significant GO terms, count how many genes with that GO term have raw pvalue < 0.05 (= "nsig")
plum.GO <- plum.GO %>%
  mutate(nsig = map_dbl(name, function(.) {
    filter(plum.genepvals, name == ., -abs(value) <= log10(0.05)) %>%
    nrow(.)
  }))
  
# Print table
(gotable <- plum.GO %>%
  unite("genes", nsig, nseqs, sep = "/") %>%
  arrange(ontology, delta.rank) %>%
  knitr::kable())
write_tsv(plum.GO %>%
  unite("genes", nsig, nseqs, sep = "/") %>%
  arrange(ontology, delta.rank), "output/plum_module_goout.txt")
```
# Run Matz code to create gomwuplot
```{r}
# Run Matz code to create gomwuplot
setwd("data/GO_MWU/")
bp <- gomwuPlot(inFile = "plum.csv", 
   goDivision = "BP", goAnnotations = "acer_iso2go.tab")
#cc <- gomwuPlot(inFile = "plum.csv", 
   #goDivision = "CC", goAnnotations = "acer_iso2go.tab")
mf <- gomwuPlot(inFile = "plum.csv", 
   goDivision = "MF", goAnnotations = "acer_iso2go.tab")
```

```{r GOMWU for Pleural pedal modules}

for(input in file.list[c(18:25)]) {
  for (division in goDivisions) {
    gomwuStats(input, goDatabase, goAnnotations, division,
               perlPath="/usr/bin/perl", # replace with full path to perl executable 
               largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
               smallest=5,   # a GO category should contain at least this many genes to be considered
               clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for 
               Module=TRUE, Alternative="g", # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 
)
# do not continue if the printout shows that no GO terms pass 10% FDR.
    
  }
} 
```




Obtain module cluster of all expressed genes (poverA = 0.85,5). Select all significantly-expressed genes (p<0.05)
```{r}
#Prepare dataframe
genes.GO <- as.data.frame(t(datt))
genes.GO <- cbind(gene_id = rownames(genes.GO), genes.GO)
rownames(genes.GO) <- NULL
# Ctrol
genesCluster1.GO <- genes.GO[,c(colnames(genes.GO) %in% rownames(sdat_A[which(sdat_A$treatment=="Control"),]))]
geneCluster <- geneInfo %>% select(gene_id, moduleCluster) #Make a dataframe containing just gene_id and moduleColor
geneCluster$gene_id <- as.factor(geneCluster$gene_id) #Make factor for merge
genesCluster1.GO$gene_id <- as.factor(genes.GO$gene_id) #Make factor for merge
genesCluster1.GO <- merge(geneColor, genesCtrl.GO) #append module information
head(genesCtrl.GO)
CtrlColors <- c("blue", "greenyellow", "brown")
genesCtrl.GO.sig <- filter(genesCtrl.GO, moduleColor%in%CtrlColors)
head(genesCtrl.GO.sig)
dim(genesCtrl.GO.sig)

#Hyp_2h
genes2h.GO <- genes.GO[,c(colnames(genes.GO) %in% rownames(sdat_A[which(sdat_A$treatment=="Hyp_T2h"),]))]
geneColor <- geneInfo %>% select(gene_id, moduleColor) #Make a dataframe containing just gene_id and moduleColor
geneColor$gene_id <- as.factor(geneColor$gene_id) #Make factor for merge
genes2h.GO$gene_id <- as.factor(genes.GO$gene_id) #Make factor for merge
genes2h.GO <- merge(geneColor, genes2h.GO) #append module information
head(genes2h.GO)
T2hColors <- c("greenyellow")
genes2h.GO.sig <- filter(genes2h.GO, moduleColor%in%T2hColors)
head(genes2h.GO.sig)
dim(genes2h.GO.sig)

#Hyp_6h
genes6h.GO <- genes.GO[,c(colnames(genes.GO) %in% rownames(sdat_A[which(sdat_A$treatment=="Hyp_T6h"),]))]
geneColor <- geneInfo %>% select(gene_id, moduleColor) #Make a dataframe containing just gene_id and moduleColor
geneColor$gene_id <- as.factor(geneColor$gene_id) #Make factor for merge
genes6h.GO$gene_id <- as.factor(genes6h.GO$gene_id) #Make factor for merge
genes6h.GO <- merge(geneColor, genes6h.GO) #append module information
head(genes6h.GO)
T6hColors <- c("coral1", "lightslateblue", "mediumpurple3", "antiquewhite2", "midnightblue")
genes6h.GO.sig <- filter(genes6h.GO, moduleColor%in%T6hColors)
head(genes6h.GO.sig)
dim(genes6h.GO.sig)

#Early ZGA
genesZGA1.GO <- genes.GO[,c(1, 7:15)]
genesZGA1.GO$gene_id <- as.factor(genesZGA1.GO$gene_id) #Make factor for merge
genesZGA1.GO <- merge(geneColor, genesZGA1.GO) #append module info ZGA1ion
head(genesZGA1.GO)
ZGA1Colors <- c("magenta4","indianred3", "blue2", "plum3", "blue4", "skyblue1", "brown2", "coral", "darkslateblue", "plum4", "violet")
genesZGA1.GO.sig <- filter(genesZGA1.GO, moduleColor%in%ZGA1Colors)
head(genesZGA1.GO.sig)
dim(genesZGA1.GO.sig)
#Cleavage
genesClvg.GO <- genes.GO[,c(1, 7:9)]
genesClvg.GO$gene_id <- as.factor(genesClvg.GO$gene_id) #Make factor for merge
genesClvg.GO <- merge(geneColor, genesClvg.GO) #append module info Clvgion
head(genesClvg.GO)
ClvgColors <- c("blue2", "violet")
genesClvg.GO.sig <- filter(genesClvg.GO, moduleColor%in%ClvgColors)
head(genesClvg.GO.sig)
dim(genesClvg.GO.sig)
#Prawn Chip
genesPC.GO <- genes.GO[,c(1, 10:12)]
genesPC.GO$gene_id <- as.factor(genesPC.GO$gene_id) #Make factor for merge
genesPC.GO <- merge(geneColor, genesPC.GO) #append module info PCion
head(genesPC.GO)
PCColors <- c("indianred3", "blue2", "plum3", "blue4", "coral", "violet")
genesPC.GO.sig <- filter(genesPC.GO, moduleColor%in%PCColors)
head(genesPC.GO.sig)
dim(genesPC.GO.sig)
#Early Gastrula
genesEG.GO <- genes.GO[,c(1, 13:15)]
genesEG.GO$gene_id <- as.factor(genesEG.GO$gene_id) #Make factor for merge
genesEG.GO <- merge(geneColor, genesEG.GO) #append module info EGion
head(genesEG.GO)
EGColors <- c("magenta4", "plum3", "blue4", "skyblue1", "brown2", "coral", "darkslateblue", "plum4")
genesEG.GO.sig <- filter(genesEG.GO, moduleColor%in%EGColors)
head(genesEG.GO.sig)
dim(genesEG.GO.sig)
#Late ZGA
genesZGA2.GO <- genes.GO[,c(1, 16:22)]
genesZGA2.GO$gene_id <- as.factor(genesZGA2.GO$gene_id) #Make factor for merge
genesZGA2.GO <- merge(geneColor, genesZGA2.GO) #append module info ZGA2ion
head(genesZGA2.GO)
ZGA2Colors <- c("magenta4", "skyblue1", "darkseagreen", "darkslateblue", "thistle4", "salmon4", "mediumpurple1", "sienna3", "salmon", "blue")
genesZGA2.GO.sig <- filter(genesZGA2.GO, moduleColor%in%ZGA2Colors)
head(genesZGA2.GO.sig)
dim(genesZGA2.GO.sig)
#Mid Gastrula
genesMG.GO <- genes.GO[,c(1, 16:17)]
genesMG.GO$gene_id <- as.factor(genesMG.GO$gene_id) #Make factor for merge
genesMG.GO <- merge(geneColor, genesMG.GO) #append module info MGion
head(genesMG.GO)
MGColors <- c("magenta4", "skyblue1", "darkseagreen", "darkslateblue", "thistle4", "salmon4")
genesMG.GO.sig <- filter(genesMG.GO, moduleColor%in%MGColors)
head(genesMG.GO.sig)
dim(genesMG.GO.sig)
#Late Gastrula
genesLG.GO <- genes.GO[,c(1, 18:19)]
genesLG.GO$gene_id <- as.factor(genesLG.GO$gene_id) #Make factor for merge
genesLG.GO <- merge(geneColor, genesLG.GO) #append module info LGion
head(genesLG.GO)
LGColors <- c("mediumpurple1", "sienna3", "thistle4", "salmon4")
genesLG.GO.sig <- filter(genesLG.GO, moduleColor%in%LGColors)
head(genesLG.GO.sig)
dim(genesLG.GO.sig)
#Planula
genesPln.GO <- genes.GO[,c(1, 20:22)]
genesPln.GO$gene_id <- as.factor(genesPln.GO$gene_id) #Make factor for merge
genesPln.GO <- merge(geneColor, genesPln.GO) #append module info Plnion
head(genesPln.GO)
PlnColors <- c("blue", "salmon", "sienna3")
genesPln.GO.sig <- filter(genesPln.GO, moduleColor%in%PlnColors)
head(genesPln.GO.sig)
dim(genesPln.GO.sig)
#Adult
genesAdult.GO <- genes.GO[,c(1, 23:25)]
genesAdult.GO$gene_id <- as.factor(genesAdult.GO$gene_id) #Make factor for merge
genesAdult.GO <- merge(geneColor, genesAdult.GO) #append module info Adult
head(genesAdult.GO)
AdultColors <- c("antiquewhite4", "thistle", "navajowhite1", "blue", "cyan", "blueviolet", "ivory")
genesAdult.GO.sig <- filter(genesAdult.GO, moduleColor%in%AdultColors)
head(genesAdult.GO.sig)
dim(genesAdult.GO.sig)
```

Find the length of each gene using the stringtie_merged.gtf as a map
```{r}
map <- read.csv(file="1-QC-Align-Assemble/Output/stringtie_merged.gtf", header=FALSE, sep="\t", skip=2) #load sample info
map <- subset(map, V3=="transcript")
map <- map[,c(1,4,5,9)]
map <- separate(map, V9, into = c("gene_id", "transcript_id", "gene_name"), sep=";")
map$gene_id <- gsub("gene_id ","",map$gene_id) #remove extra characters
map$gene_id <- gsub(" ","",map$gene_id) #remove extra characters
map$transcript_id <- gsub("transcript_id ","",map$transcript_id) #remove extra characters
map$transcript_id <- gsub(" ","",map$transcript_id) #remove extra characters
map$gene_name <- gsub("ref_gene_id ","",map$gene_name) #remove extra characters
# map$gene_name <- gsub("gene_name ","",map$gene_name) #remove extra characters
map$gene_name <- gsub(" ","",map$gene_name) #remove extra characters
# map$gene_name <- gsub("xlocXLOC_[0-9][0-9][0-9][0-9][0-9][0-9]", "unknown", map$gene_name)
colnames(map) <- c("scaffold", "start", "stop", "gene_name", "transcript_id", "gene_id")
dim(map)
head(map)
map <- filter(map, gene_id %in% genes.GO$gene_id) #Filter for those genes in our set of interest
dim(map) #Should be 32772
#Calculate gene length
map <- map %>% mutate(gene_length=(map$stop-map$start))
map <- select(map, gene_id, gene_length)
```

Build a data frame that links the gene IDs, modules, and counts of expressed maternal genes (poverA = 0.09,5) and the gene lengths.
```{r}
GOref <- merge(genes.GO, map, by.x="gene_id")
head(GOref)
dim(GOref) #Should have 32772
```

GOseq requires a vector of all genes and all differentially expressed genes. 
```{r, message=FALSE, warning=FALSE, echo=FALSE}
#Maternal
Matgene.vector <- as.vector(genesMat.GO.sig$gene_id)
Matgene.vector=as.integer(GOref$gene_id%in%Matgene.vector)
names(Matgene.vector)=GOref$gene_id
head(Matgene.vector)
MatID.vector <- GOref$gene_id #Make ID vector
head(MatID.vector)
dim(MatID.vector)
MatLength.vector <- GOref$gene_length #Make length vector
head(MatLength.vector)
UEgene.vector <- as.vector(genesUE.GO.sig$gene_id)
UEgene.vector=as.integer(GOref$gene_id%in%UEgene.vector)
names(UEgene.vector)=GOref$gene_id
head(UEgene.vector)
UEID.vector <- GOref$gene_id #Make ID vector
head(UEID.vector)
dim(UEID.vector)
UELength.vector <- GOref$gene_length #Make length vector
head(UELength.vector)
FEgene.vector <- as.vector(genesFE.GO.sig$gene_id)
FEgene.vector=as.integer(GOref$gene_id%in%FEgene.vector)
names(FEgene.vector)=GOref$gene_id
head(FEgene.vector)
FEID.vector <- GOref$gene_id #Make ID vector
head(FEID.vector)
dim(FEID.vector)
FELength.vector <- GOref$gene_length #Make length vector
head(FELength.vector)
#First ZGA
ZGA1gene.vector <- as.vector(genesZGA1.GO.sig$gene_id)
ZGA1gene.vector=as.integer(GOref$gene_id%in%ZGA1gene.vector)
names(ZGA1gene.vector)=GOref$gene_id
head(ZGA1gene.vector)
ZGA1ID.vector <- GOref$gene_id #Make ID vector
head(ZGA1ID.vector)
ZGA1Length.vector <- GOref$gene_length #Make length vector
head(ZGA1Length.vector)
Clvggene.vector <- as.vector(genesClvg.GO.sig$gene_id)
Clvggene.vector=as.integer(GOref$gene_id%in%Clvggene.vector)
names(Clvggene.vector)=GOref$gene_id
head(Clvggene.vector)
ClvgID.vector <- GOref$gene_id #Make ID vector
head(ClvgID.vector)
ClvgLength.vector <- GOref$gene_length #Make length vector
head(ClvgLength.vector)
PCgene.vector <- as.vector(genesPC.GO.sig$gene_id)
PCgene.vector=as.integer(GOref$gene_id%in%PCgene.vector)
names(PCgene.vector)=GOref$gene_id
head(PCgene.vector)
PCID.vector <- GOref$gene_id #Make ID vector
head(PCID.vector)
PCLength.vector <- GOref$gene_length #Make length vector
head(PCLength.vector)
EGgene.vector <- as.vector(genesEG.GO.sig$gene_id)
EGgene.vector=as.integer(GOref$gene_id%in%EGgene.vector)
names(EGgene.vector)=GOref$gene_id
head(EGgene.vector)
EGID.vector <- GOref$gene_id #Make ID vector
head(EGID.vector)
EGLength.vector <- GOref$gene_length #Make length vector
head(EGLength.vector)
#Second ZGA
ZGA2gene.vector <- as.vector(genesZGA2.GO.sig$gene_id)
ZGA2gene.vector=as.integer(GOref$gene_id%in%ZGA2gene.vector)
names(ZGA2gene.vector)=GOref$gene_id
head(ZGA2gene.vector)
ZGA2ID.vector <- GOref$gene_id #Make ID vector
head(ZGA2ID.vector)
ZGA2Length.vector <- GOref$gene_length #Make length vector
head(ZGA2Length.vector)
MGgene.vector <- as.vector(genesMG.GO.sig$gene_id)
MGgene.vector=as.integer(GOref$gene_id%in%MGgene.vector)
names(MGgene.vector)=GOref$gene_id
head(MGgene.vector)
MGID.vector <- GOref$gene_id #Make ID vector
head(MGID.vector)
MGLength.vector <- GOref$gene_length #Make length vector
head(MGLength.vector)
LGgene.vector <- as.vector(genesLG.GO.sig$gene_id)
LGgene.vector=as.integer(GOref$gene_id%in%LGgene.vector)
names(LGgene.vector)=GOref$gene_id
head(LGgene.vector)
LGID.vector <- GOref$gene_id #Make ID vector
head(LGID.vector)
LGLength.vector <- GOref$gene_length #Make length vector
head(LGLength.vector)
Plngene.vector <- as.vector(genesPln.GO.sig$gene_id)
Plngene.vector=as.integer(GOref$gene_id%in%Plngene.vector)
names(Plngene.vector)=GOref$gene_id
head(Plngene.vector)
PlnID.vector <- GOref$gene_id #Make ID vector
head(PlnID.vector)
PlnLength.vector <- GOref$gene_length #Make length vector
head(PlnLength.vector)
#Adult
Adultgene.vector <- as.vector(genesAdult.GO.sig$gene_id)
Adultgene.vector=as.integer(GOref$gene_id%in%Adultgene.vector)
names(Adultgene.vector)=GOref$gene_id
head(Adultgene.vector)
AdultID.vector <- GOref$gene_id #Make ID vector
head(AdultID.vector)
AdultLength.vector <- GOref$gene_length #Make length vector
head(AdultLength.vector)
#Calculate Probability Weighting Function
pwf.Mat<-nullp(Matgene.vector, MatID.vector, bias.data=MatLength.vector) #weight vector by length of gene
pwf.UE<-nullp(UEgene.vector, UEID.vector, bias.data=UELength.vector) #weight vector by length of gene
pwf.FE<-nullp(FEgene.vector, FEID.vector, bias.data=FELength.vector) #weight vector by length of gene
pwf.ZGA1<-nullp(ZGA1gene.vector, ZGA1ID.vector, bias.data=ZGA1Length.vector) #weight vector by length of gene
pwf.Clvg<-nullp(Clvggene.vector, ClvgID.vector, bias.data=ClvgLength.vector) #weight vector by length of gene
pwf.PC<-nullp(PCgene.vector, PCID.vector, bias.data=PCLength.vector) #weight vector by length of gene
pwf.EG<-nullp(EGgene.vector, EGID.vector, bias.data=EGLength.vector) #weight vector by length of gene
pwf.ZGA2<-nullp(ZGA2gene.vector, ZGA2ID.vector, bias.data=ZGA2Length.vector) #weight vector by length of gene
pwf.MG<-nullp(MGgene.vector, MGID.vector, bias.data=MGLength.vector) #weight vector by length of gene
pwf.LG<-nullp(LGgene.vector, LGID.vector, bias.data=LGLength.vector) #weight vector by length of gene
pwf.Pln<-nullp(Plngene.vector, PlnID.vector, bias.data=PlnLength.vector) #weight vector by length of gene
pwf.Adult<-nullp(Adultgene.vector, AdultID.vector, bias.data=AdultLength.vector) #weight vector by length of gene
```

Prepare GO term dataframe
```{r}
GO.annot <- select(geneInfo, gene_id, Annotation.GO.ID)
splitted <- strsplit(as.character(GO.annot$Annotation.GO.ID), ";") #split into multiple GO ids
GO.terms <- data.frame(v1 = rep.int(GO.annot$gene_id, sapply(splitted, length)), v2 = unlist(splitted)) #list all genes with each of their GO terms in a single row
colnames(GO.terms) <- c("gene_id", "GO.ID")
head(GO.terms)
tail(GO.terms)
GO.terms$GO.ID<- as.character(GO.terms$GO.ID)
GO.terms$GO.ID <- replace_na(GO.terms$GO.ID, "unknown")
GO.terms$GO.ID <- as.factor(GO.terms$GO.ID)
GO.terms$gene_id <- as.factor(GO.terms$gene_id)
GO.terms$GO.ID <- gsub(" ", "", GO.terms$GO.ID)
GO.terms <- unique(GO.terms)
dim(GO.terms)
head(GO.terms, 10)
tail(GO.terms, 10)
```

Find enriched GO terms, "selection-unbiased testing for category enrichment amongst significantly expressed genes for RNA-seq data"
```{r, warning=FALSE, message=FALSE}
GOwall.Mat <- goseq(pwf.Mat, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
dim(GOwall.Mat)
head(GOwall.Mat)
GOwall.UE <- goseq(pwf.UE, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.FE <- goseq(pwf.FE, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.ZGA1 <- goseq(pwf.ZGA1, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.Clvg <- goseq(pwf.Clvg, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.PC <- goseq(pwf.PC, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.EG <- goseq(pwf.EG, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.ZGA2 <- goseq(pwf.ZGA2, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.MG <- goseq(pwf.MG, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.LG <- goseq(pwf.LG, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.Pln <- goseq(pwf.Pln, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
GOwall.Adult <- goseq(pwf.Adult, GOref$gene_id, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
```

Find only enriched GO terms that are statistically significant at cutoff
```{r}
Mat.GO.05<-GOwall.Mat$category[GOwall.Mat$over_represented_pvalue<.05]
Mat.GO.05<-data.frame(Mat.GO.05)
colnames(Mat.GO.05) <- c("category")
Mat.GO.05 <- merge(Mat.GO.05, GOwall.Mat, by="category")
Mat.GO.05 <- Mat.GO.05[order(Mat.GO.05$ontology, Mat.GO.05$over_represented_pvalue, -Mat.GO.05$numDEInCat),]
Mat.GO.05$term <- as.factor(Mat.GO.05$term)
dim(Mat.GO.05) #Number of sig GO terms
nrow(filter(Mat.GO.05, ontology=="BP")) #number sig BP terms
UE.GO.05<-GOwall.UE$category[GOwall.UE$over_represented_pvalue<.05]
UE.GO.05<-data.frame(UE.GO.05)
colnames(UE.GO.05) <- c("category")
UE.GO.05 <- merge(UE.GO.05, GOwall.UE, by="category")
UE.GO.05 <- UE.GO.05[order(UE.GO.05$ontology, UE.GO.05$over_represented_pvalue, -UE.GO.05$numDEInCat),]
UE.GO.05$term <- as.factor(UE.GO.05$term)
dim(UE.GO.05) #Number of sig GO terms
nrow(filter(UE.GO.05, ontology=="BP")) #number sig BP terms
FE.GO.05<-GOwall.FE$category[GOwall.FE$over_represented_pvalue<.05]
FE.GO.05<-data.frame(FE.GO.05)
colnames(FE.GO.05) <- c("category")
FE.GO.05 <- merge(FE.GO.05, GOwall.FE, by="category")
FE.GO.05 <- FE.GO.05[order(FE.GO.05$ontology, FE.GO.05$over_represented_pvalue, -FE.GO.05$numDEInCat),]
FE.GO.05$term <- as.factor(FE.GO.05$term)
dim(FE.GO.05) #Number of sig GO terms
nrow(filter(FE.GO.05, ontology=="BP")) #number sig BP terms
ZGA1.GO.05<-GOwall.ZGA1$category[GOwall.ZGA1$over_represented_pvalue<.05]
ZGA1.GO.05<-data.frame(ZGA1.GO.05)
colnames(ZGA1.GO.05) <- c("category")
ZGA1.GO.05 <- merge(ZGA1.GO.05, GOwall.ZGA1, by="category")
ZGA1.GO.05 <- ZGA1.GO.05[order(ZGA1.GO.05$ontology, ZGA1.GO.05$over_represented_pvalue, -ZGA1.GO.05$numDEInCat),]
ZGA1.GO.05$term <- as.factor(ZGA1.GO.05$term)
dim(ZGA1.GO.05) #Number of sig GO terms
nrow(filter(ZGA1.GO.05, ontology=="BP")) #number sig BP terms
Clvg.GO.05<-GOwall.Clvg$category[GOwall.Clvg$over_represented_pvalue<.05]
Clvg.GO.05<-data.frame(Clvg.GO.05)
colnames(Clvg.GO.05) <- c("category")
Clvg.GO.05 <- merge(Clvg.GO.05, GOwall.Clvg, by="category")
Clvg.GO.05 <- Clvg.GO.05[order(Clvg.GO.05$ontology, Clvg.GO.05$over_represented_pvalue, -Clvg.GO.05$numDEInCat),]
Clvg.GO.05$term <- as.factor(Clvg.GO.05$term)
dim(Clvg.GO.05) #Number of sig GO terms
nrow(filter(Clvg.GO.05, ontology=="BP")) #number sig BP terms
PC.GO.05<-GOwall.PC$category[GOwall.PC$over_represented_pvalue<.05]
PC.GO.05<-data.frame(PC.GO.05)
colnames(PC.GO.05) <- c("category")
PC.GO.05 <- merge(PC.GO.05, GOwall.PC, by="category")
PC.GO.05 <- PC.GO.05[order(PC.GO.05$ontology, PC.GO.05$over_represented_pvalue, -PC.GO.05$numDEInCat),]
PC.GO.05$term <- as.factor(PC.GO.05$term)
dim(PC.GO.05) #Number of sig GO terms
nrow(filter(PC.GO.05, ontology=="BP")) #number sig BP terms
EG.GO.05<-GOwall.EG$category[GOwall.EG$over_represented_pvalue<.05]
EG.GO.05<-data.frame(EG.GO.05)
colnames(EG.GO.05) <- c("category")
EG.GO.05 <- merge(EG.GO.05, GOwall.EG, by="category")
EG.GO.05 <- EG.GO.05[order(EG.GO.05$ontology, EG.GO.05$over_represented_pvalue, -EG.GO.05$numDEInCat),]
EG.GO.05$term <- as.factor(EG.GO.05$term)
dim(EG.GO.05) #Number of sig GO terms
nrow(filter(EG.GO.05, ontology=="BP")) #number sig BP terms
ZGA2.GO.05<-GOwall.ZGA2$category[GOwall.ZGA2$over_represented_pvalue<.05]
ZGA2.GO.05<-data.frame(ZGA2.GO.05)
colnames(ZGA2.GO.05) <- c("category")
ZGA2.GO.05 <- merge(ZGA2.GO.05, GOwall.ZGA2, by="category")
ZGA2.GO.05 <- ZGA2.GO.05[order(ZGA2.GO.05$ontology, ZGA2.GO.05$over_represented_pvalue, -ZGA2.GO.05$numDEInCat),]
ZGA2.GO.05$term <- as.factor(ZGA2.GO.05$term)
dim(ZGA2.GO.05) #Number of sig GO terms
nrow(filter(ZGA2.GO.05, ontology=="BP")) #number sig BP terms
MG.GO.05<-GOwall.MG$category[GOwall.MG$over_represented_pvalue<.05]
MG.GO.05<-data.frame(MG.GO.05)
colnames(MG.GO.05) <- c("category")
MG.GO.05 <- merge(MG.GO.05, GOwall.MG, by="category")
MG.GO.05 <- MG.GO.05[order(MG.GO.05$ontology, MG.GO.05$over_represented_pvalue, -MG.GO.05$numDEInCat),]
MG.GO.05$term <- as.factor(MG.GO.05$term)
dim(MG.GO.05) #Number of sig GO terms
nrow(filter(MG.GO.05, ontology=="BP")) #number sig BP terms
LG.GO.05<-GOwall.LG$category[GOwall.LG$over_represented_pvalue<.05]
LG.GO.05<-data.frame(LG.GO.05)
colnames(LG.GO.05) <- c("category")
LG.GO.05 <- merge(LG.GO.05, GOwall.LG, by="category")
LG.GO.05 <- LG.GO.05[order(LG.GO.05$ontology, LG.GO.05$over_represented_pvalue, -LG.GO.05$numDEInCat),]
LG.GO.05$term <- as.factor(LG.GO.05$term)
dim(LG.GO.05) #Number of sig GO terms
nrow(filter(LG.GO.05, ontology=="BP")) #number sig BP terms
Pln.GO.05<-GOwall.Pln$category[GOwall.Pln$over_represented_pvalue<.05]
Pln.GO.05<-data.frame(Pln.GO.05)
colnames(Pln.GO.05) <- c("category")
Pln.GO.05 <- merge(Pln.GO.05, GOwall.Pln, by="category")
Pln.GO.05 <- Pln.GO.05[order(Pln.GO.05$ontology, Pln.GO.05$over_represented_pvalue, -Pln.GO.05$numDEInCat),]
Pln.GO.05$term <- as.factor(Pln.GO.05$term)
dim(Pln.GO.05) #Number of sig GO terms
nrow(filter(Pln.GO.05, ontology=="BP")) #number sig BP terms
Adult.GO.05<-GOwall.Adult$category[GOwall.Adult$over_represented_pvalue<.05]
Adult.GO.05<-data.frame(Adult.GO.05)
colnames(Adult.GO.05) <- c("category")
Adult.GO.05 <- merge(Adult.GO.05, GOwall.Adult, by="category")
Adult.GO.05 <- Adult.GO.05[order(Adult.GO.05$ontology, Adult.GO.05$over_represented_pvalue, -Adult.GO.05$numDEInCat),]
Adult.GO.05$term <- as.factor(Adult.GO.05$term)
dim(Adult.GO.05) #Number of sig GO terms
nrow(filter(Adult.GO.05, ontology=="BP")) #number sig BP terms
```

Correct any un-annotated terms/ontologies
```{r}
NAs.ontology <- Mat.GO.05 %>% subset(is.na(term))
print(NAs.ontology)
NAs.ontology <- ZGA1.GO.05 %>% subset(is.na(term))
print(NAs.ontology)
NAs.ontology <- ZGA2.GO.05 %>% subset(is.na(term))
print(NAs.ontology)
NAs.ontology <- Adult.GO.05 %>% subset(is.na(term))
print(NAs.ontology)
```
*There were no un-annotated functions except genes with unknown functions*

Save significant terms
```{r, warning=FALSE}
write.csv(Mat.GO.05, file = "2a-WGCNA/Output/GO.05.Mat.csv", row.names = FALSE)
write.csv(UE.GO.05, file = "2a-WGCNA/Output/GO.05.UE.csv", row.names = FALSE)
write.csv(FE.GO.05, file = "2a-WGCNA/Output/GO.05.FE.csv", row.names = FALSE)
write.csv(ZGA1.GO.05, file = "2a-WGCNA/Output/GO.05.ZGA1.csv", row.names = FALSE)
write.csv(Clvg.GO.05, file = "2a-WGCNA/Output/GO.05.Clvg.csv", row.names = FALSE)
write.csv(PC.GO.05, file = "2a-WGCNA/Output/GO.05.PC.csv", row.names = FALSE)
write.csv(EG.GO.05, file = "2a-WGCNA/Output/GO.05.EG.csv", row.names = FALSE)
write.csv(ZGA2.GO.05, file = "2a-WGCNA/Output/GO.05.ZGA2.csv", row.names = FALSE)
write.csv(MG.GO.05, file = "2a-WGCNA/Output/GO.05.MG.csv", row.names = FALSE)
write.csv(LG.GO.05, file = "2a-WGCNA/Output/GO.05.LG.csv", row.names = FALSE)
write.csv(Pln.GO.05, file = "2a-WGCNA/Output/GO.05.Pln.csv", row.names = FALSE)
write.csv(Adult.GO.05, file = "2a-WGCNA/Output/GO.05.Adult.csv", row.names = FALSE)
```

### KEGG enrichment of maternal modules

### KEGG Pathway Analysis of Maternal Transcriptome

Prepare a KEGG vector of differentially expressed
```{r}
# head(KEGGinfo)
# 
# KEGGinfo <- select(geneInfo, gene_id, KEGG)
# KEGGinfo <- filter(KEGGinfo, KEGG != "0") #Keep on Kegg IDs in Kegg column
# KEGGinfo <- unique(KEGGinfo)
# KEGGinfo$KEGG <- as.factor(KEGGinfo$KEGG) #Every column must be a factor
# KEGGinfo$gene_id <- as.factor(KEGGinfo$gene_id) #Every column must be a factor
# dim(KEGGinfo)
# head(KEGGinfo)
# 
# 
# 
# KEGG_input_maternal <- filter(KEGGinfo, gene_id%in%genesMat.GO.sig$gene_id) #Filter for gene IDs in the maternal set
# head(KEGG_input_maternal)
# dim(KEGG_input_maternal)
# write.table(KEGG_input_maternal, "Output/RNAseq/maternal.05.KEGG_mapper_input.txt", quote=FALSE,col.names=FALSE,row.names=FALSE,sep="\t") #TO BE USED FOR KEGG Mapper https://www.genome.jp/kegg/mapper.html.
```

Perform enrichment analysis
```{r}
# KEGG.05.maternal <- enrichKEGG(KEGG_input_maternal$KEGG, organism = "ko", keyType = "kegg", pvalueCutoff = 0.05) #run enrichment with Kegg sig < 0.05
# KEGG.05.maternal <- KEGG.05.maternal[order(KEGG.05.maternal$p.adjust, -KEGG.05.maternal$Count),] #order by p-value, then count
# head(KEGG.05.maternal) #analysis of DE genes
# dim(KEGG.05.maternal)
# write.csv(KEGG.05.maternal, file = "Output/RNAseq/KEGG.05.maternal.csv")
```

### Obtain signicant GO terms for each module

Make a list of all module colors
```{r}
moduleColor_list <- unique(geneColor$moduleColor)
moduleColor_list
```

Obtain module color of all expressed genes (poverA = 0.85,5).
```{r}
genes.GO$gene_id <- as.factor(genes.GO$gene_id) #Make factor for merge
genes.GO <- merge(geneColor, genes.GO) #append module information
genes.GO$moduleColor <- as.factor(genes.GO$moduleColor) #Make factor for filter
head(genes.GO)
dim(genes.GO)
```

Obtain list of significantly-expressed genes for each module
```{r}
antiquewhite2.sig <- filter(genes.GO, moduleColor=="antiquewhite2")
antiquewhite4.sig <- filter(genes.GO, moduleColor=="antiquewhite4")
blue.sig <- filter(genes.GO, moduleColor=="blue")
blue2.sig <- filter(genes.GO, moduleColor=="blue2")
blue4.sig <- filter(genes.GO, moduleColor=="blue4")
blueviolet.sig <- filter(genes.GO, moduleColor=="blueviolet")
brown2.sig <- filter(genes.GO, moduleColor=="brown2")
coral.sig <- filter(genes.GO, moduleColor=="coral")
coral1.sig <- filter(genes.GO, moduleColor=="coral1")
cyan.sig <- filter(genes.GO, moduleColor=="cyan")
darkmagenta.sig <- filter(genes.GO, moduleColor=="darkmagenta")
darkseagreen4.sig <- filter(genes.GO, moduleColor=="darkseagreen4")
darkslateblue.sig <- filter(genes.GO, moduleColor=="darkslateblue")
grey.sig <- filter(genes.GO, moduleColor=="grey")
honeydew1.sig <- filter(genes.GO, moduleColor=="honeydew1")
indianred3.sig <- filter(genes.GO, moduleColor=="indianred3")
ivory.sig <- filter(genes.GO, moduleColor=="ivory")
lavenderblush2.sig <- filter(genes.GO, moduleColor=="lavenderblush2")
lightslateblue.sig <- filter(genes.GO, moduleColor=="lightslateblue")
lightsteelblue.sig <- filter(genes.GO, moduleColor=="lightsteelblue")
magenta4.sig <- filter(genes.GO, moduleColor=="magenta4")
mediumpurple1.sig <- filter(genes.GO, moduleColor=="mediumpurple1")
mediumpurple3.sig <- filter(genes.GO, moduleColor=="mediumpurple3")
midnightblue.sig <- filter(genes.GO, moduleColor=="midnightblue")
navajowhite1.sig <- filter(genes.GO, moduleColor=="navajowhite1")
plum3.sig <- filter(genes.GO, moduleColor=="plum3")
plum4.sig <- filter(genes.GO, moduleColor=="plum4")
salmon.sig <- filter(genes.GO, moduleColor=="salmon")
salmon4.sig <- filter(genes.GO, moduleColor=="salmon4")
sienna3.sig <- filter(genes.GO, moduleColor=="sienna3")
skyblue1.sig <- filter(genes.GO, moduleColor=="skyblue1")
thistle.sig <- filter(genes.GO, moduleColor=="thistle")
thistle4.sig <- filter(genes.GO, moduleColor=="thistle4")
violet.sig <- filter(genes.GO, moduleColor=="violet")
```

GOseq requires a vector of all genes and all differentially expressed genes. 
```{r, message=FALSE, warning=FALSE}
antiquewhite2.vector <- as.vector(antiquewhite2.sig$gene_id)
antiquewhite2.vector=as.integer(GOref$gene_id%in%antiquewhite2.vector)
names(antiquewhite2.vector)=GOref$gene_id
antiquewhite4.vector <- as.vector(antiquewhite4.sig$gene_id)
antiquewhite4.vector=as.integer(GOref$gene_id%in%antiquewhite4.vector)
names(antiquewhite4.vector)=GOref$gene_id
blue.vector <- as.vector(blue.sig$gene_id)
blue.vector=as.integer(GOref$gene_id%in%blue.vector)
names(blue.vector)=GOref$gene_id
blue2.vector <- as.vector(blue2.sig$gene_id)
blue2.vector=as.integer(GOref$gene_id%in%blue2.vector)
names(blue2.vector)=GOref$gene_id
blue4.vector <- as.vector(blue4.sig$gene_id)
blue4.vector=as.integer(GOref$gene_id%in%blue4.vector)
names(blue4.vector)=GOref$gene_id
blueviolet.vector <- as.vector(blueviolet.sig$gene_id)
blueviolet.vector=as.integer(GOref$gene_id%in%blueviolet.vector)
names(blueviolet.vector)=GOref$gene_id
brown2.vector <- as.vector(brown2.sig$gene_id)
brown2.vector=as.integer(GOref$gene_id%in%brown2.vector)
names(brown2.vector)=GOref$gene_id
coral.vector <- as.vector(coral.sig$gene_id)
coral.vector=as.integer(GOref$gene_id%in%coral.vector)
names(coral.vector)=GOref$gene_id
coral1.vector <- as.vector(coral1.sig$gene_id)
coral1.vector=as.integer(GOref$gene_id%in%coral1.vector)
names(coral1.vector)=GOref$gene_id
cyan.vector <- as.vector(cyan.sig$gene_id)
cyan.vector=as.integer(GOref$gene_id%in%cyan.vector)
names(cyan.vector)=GOref$gene_id
darkmagenta.vector <- as.vector(darkmagenta.sig$gene_id)
darkmagenta.vector=as.integer(GOref$gene_id%in%darkmagenta.vector)
names(darkmagenta.vector)=GOref$gene_id
darkseagreen4.vector <- as.vector(darkseagreen4.sig$gene_id)
darkseagreen4.vector=as.integer(GOref$gene_id%in%darkseagreen4.vector)
names(darkseagreen4.vector)=GOref$gene_id
darkslateblue.vector <- as.vector(darkslateblue.sig$gene_id)
darkslateblue.vector=as.integer(GOref$gene_id%in%darkslateblue.vector)
names(darkslateblue.vector)=GOref$gene_id
grey.vector <- as.vector(grey.sig$gene_id)
grey.vector=as.integer(GOref$gene_id%in%grey.vector)
names(grey.vector)=GOref$gene_id
honeydew1.vector <- as.vector(honeydew1.sig$gene_id)
honeydew1.vector=as.integer(GOref$gene_id%in%honeydew1.vector)
names(honeydew1.vector)=GOref$gene_id
indianred3.vector <- as.vector(indianred3.sig$gene_id)
indianred3.vector=as.integer(GOref$gene_id%in%indianred3.vector)
names(indianred3.vector)=GOref$gene_id
ivory.vector <- as.vector(ivory.sig$gene_id)
ivory.vector=as.integer(GOref$gene_id%in%ivory.vector)
names(ivory.vector)=GOref$gene_id
lavenderblush2.vector <- as.vector(lavenderblush2.sig$gene_id)
lavenderblush2.vector=as.integer(GOref$gene_id%in%lavenderblush2.vector)
names(lavenderblush2.vector)=GOref$gene_id
lightslateblue.vector <- as.vector(lightslateblue.sig$gene_id)
lightslateblue.vector=as.integer(GOref$gene_id%in%lightslateblue.vector)
names(lightslateblue.vector)=GOref$gene_id
lightsteelblue.vector <- as.vector(lightsteelblue.sig$gene_id)
lightsteelblue.vector=as.integer(GOref$gene_id%in%lightsteelblue.vector)
names(lightsteelblue.vector)=GOref$gene_id
magenta4.vector <- as.vector(magenta4.sig$gene_id)
magenta4.vector=as.integer(GOref$gene_id%in%magenta4.vector)
names(magenta4.vector)=GOref$gene_id
mediumpurple1.vector <- as.vector(mediumpurple1.sig$gene_id)
mediumpurple1.vector=as.integer(GOref$gene_id%in%mediumpurple1.vector)
names(mediumpurple1.vector)=GOref$gene_id
mediumpurple3.vector <- as.vector(mediumpurple3.sig$gene_id)
mediumpurple3.vector=as.integer(GOref$gene_id%in%mediumpurple3.vector)
names(mediumpurple3.vector)=GOref$gene_id
midnightblue.vector <- as.vector(midnightblue.sig$gene_id)
midnightblue.vector=as.integer(GOref$gene_id%in%midnightblue.vector)
names(midnightblue.vector)=GOref$gene_id
navajowhite1.vector <- as.vector(navajowhite1.sig$gene_id)
navajowhite1.vector=as.integer(GOref$gene_id%in%navajowhite1.vector)
names(navajowhite1.vector)=GOref$gene_id
plum3.vector <- as.vector(plum3.sig$gene_id)
plum3.vector=as.integer(GOref$gene_id%in%plum3.vector)
names(plum3.vector)=GOref$gene_id
plum4.vector <- as.vector(plum4.sig$gene_id)
plum4.vector=as.integer(GOref$gene_id%in%plum4.vector)
names(plum4.vector)=GOref$gene_id
salmon.vector <- as.vector(salmon.sig$gene_id)
salmon.vector=as.integer(GOref$gene_id%in%salmon.vector)
names(salmon.vector)=GOref$gene_id
salmon4.vector <- as.vector(salmon4.sig$gene_id)
salmon4.vector=as.integer(GOref$gene_id%in%salmon4.vector)
names(salmon4.vector)=GOref$gene_id
sienna3.vector <- as.vector(sienna3.sig$gene_id)
sienna3.vector=as.integer(GOref$gene_id%in%sienna3.vector)
names(sienna3.vector)=GOref$gene_id
skyblue1.vector <- as.vector(skyblue1.sig$gene_id)
skyblue1.vector=as.integer(GOref$gene_id%in%skyblue1.vector)
names(skyblue1.vector)=GOref$gene_id
thistle.vector <- as.vector(thistle.sig$gene_id)
thistle.vector=as.integer(GOref$gene_id%in%thistle.vector)
names(thistle.vector)=GOref$gene_id
thistle4.vector <- as.vector(thistle4.sig$gene_id)
thistle4.vector=as.integer(GOref$gene_id%in%thistle4.vector)
names(thistle4.vector)=GOref$gene_id
violet.vector <- as.vector(violet.sig$gene_id)
violet.vector=as.integer(GOref$gene_id%in%violet.vector)
names(violet.vector)=GOref$gene_id
vector.list <- list(antiquewhite2.vector, antiquewhite4.vector, blue.vector, blue2.vector, blue4.vector, blueviolet.vector, brown2.vector, coral.vector, coral1.vector, cyan.vector, darkmagenta.vector, darkseagreen4.vector, darkslateblue.vector, grey.vector, honeydew1.vector, indianred3.vector, ivory.vector, lavenderblush2.vector, lightslateblue.vector, lightsteelblue.vector, magenta4.vector, mediumpurple1.vector, mediumpurple3.vector, midnightblue.vector, navajowhite1.vector, plum3.vector, plum4.vector, salmon.vector, salmon4.vector, sienna3.vector, skyblue1.vector, thistle.vector, thistle4.vector, violet.vector)
length(vector.list)
```

Calculate Probability Weighting Function
```{r, message=FALSE, warning=FALSE, echo=FALSE}
pwf <- lapply(vector.list, nullp, MatID.vector, bias.data=MatLength.vector)#weight vector by length of gene
```

Perform goseq
```{r, message=FALSE, warning=FALSE}
GOwall <- lapply(pwf, goseq, gene2cat=GO.terms, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)
```

Find only enriched GO terms that are statistically significant at cutoff. Order by p-value and select top 10 most significant terms for each module.
```{r}
GO.05<-lapply(GOwall, filter, over_represented_pvalue<.05)
GO.05 <- lapply(GO.05, function(GO.05){GO.05[order(GO.05$over_represented_pvalue, -GO.05$numDEInCat),]})
names(GO.05) = moduleColor_list #name the dataframes according to their color
GO.05.all <- bind_rows(GO.05, .id = "column_label") #merge the dataframes using the name as an identifier
GO.05.all <- rename(GO.05.all,"moduleColor"="column_label") #rename the identifying column
GO.05.all <- merge(moduleCluster, GO.05.all, by = "moduleColor") #Add cluster information
GO.05.all <- GO.05.all[order(factor(GO.05.all$moduleColor, levels = moduleCluster$moduleColor)),] #Match order to heatmap
GO.05.all <- subset(GO.05.all, select = c(2,1, 3:9)) #make cluster first, then module second
GO.05.top10 <- lapply(GO.05, "[",c(1:10),,drop=FALSE)
```

Merge list into 1 dataframe to obtain top 10
```{r}
names(GO.05.top10) = moduleColor_list #name the dataframes according to their color
GO.05.top10.all <- bind_rows(GO.05.top10, .id = "column_label") #merge the dataframes using the name as an identifier
GO.05.top10.all <- rename(GO.05.top10.all, "moduleColor"="column_label") #rename the identifying column
GO.05.top10.all <- merge(moduleCluster, GO.05.top10.all, by = "moduleColor") #Add cluster information
GO.05.top10.all <- GO.05.top10.all[order(factor(GO.05.top10.all$moduleColor, levels = moduleCluster$moduleColor)),] #Match order to heatmap
GO.05.top10.all <- subset(GO.05.top10.all, select = c(2,1, 3:9)) #make cluster first, then module second
head(GO.05.top10.all)
tail(GO.05.top10.all)
str(GO.05.top10.all)
```


Save as CSV
```{r}
#write.csv(GO.05.top10.all, file = "Output/RNAseq/WGCNA.GO.05.top10.csv")
write.csv(GO.05.all, file = "2a-WGCNA/Output/GO.05.allMods.csv")
```